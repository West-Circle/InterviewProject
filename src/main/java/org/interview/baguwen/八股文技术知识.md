# JAVA

## 基础

- Integer、Byte、Short、Long的缓存数据范围(-128~127)，Character是0到127
- float32位，符号1位，指数8位，尾数23位。double64位，符号1位，指数11位，尾数52位。用BigDecimal计算金额，怕精度丢失
- short s1=1, s1=s1+1错，因为会自动提升转换类型为int然后赋值给short出现错误，short s1;s1+=1是特殊处理，可以编译通过。
- switch可以作用在byte、int、string(1.7后)
- Object类哪些方法：clone, getClass, toString, equals, hashCode, wait, notify, finalize
- ==比较内存地址，equals比较内容。
- **Java反射机制**：指在程序运行状态中，可以构造任意一个类的对象，可以调用任意一个对象的属性和方法，动态调用程序信息以及功能。可能会不安全因为私有变量可以被外部访问，破坏了封装概念。应用在框架的开发，动态代理，对象序列化等。可通过外部类的全路径名创建对象，实现扩展功能、测试时可以利用发射API访问类的私有成员，保证测试代码覆盖率。Class student = Class.forName("包名称xx.Student"). User.class / user.getClass()
- **面向对象特征**：封装、继承、多态（抽象）动态调用子类方法（动态绑定Java默认）
- 封装：数据和方法隐藏，只暴露接口、代码复用，封装成可重用模块对象、简化开发，隐藏了细节，只需要关注对象提供的接口。缺点：增加代码复杂性、限制灵活性。
- 组合：不破坏封装，整体类与局部类之间松耦合，彼此相对独立，具有扩展性。缺点：创建整体类对象，需要创建所有局部类对象才能组合一起、整体类不能自动获得局部类同样接口。
- **面向过程**-以事件为中心，编程时把解决步骤分析，然后实现，五子棋 游戏
- **面向对象**-把每一个事务看作一个对象，每个对象有自己的属性和行为，把解决问题分解成各个对象。
- **面向过程**优点-流程化任务明确效率高，性能高于面向对象，缺点-需要深入思考，耗费精力，没有易维护、易扩展
- **面向对象**优点-程序模块化和结构化，易扩展性代码重用率高，可继承，可覆盖，设计出低耦合高内聚系统，易维护系统低耦合有利于减少程序后期维护，缺点-开销大修改内部对象对象属性不允许外部直接存取，性能比面向过程低
- abstract和interface区别：

## 相同点：

1、都不能被实例化。 2、接口的实现类和抽象类的子类只有全部实现了接口或者抽象类中的方法后才可以被实例化。

## 不同点：

1、接口只能定义抽象方法不能实现方法，抽象类既可以定义抽象方法，也可以实现方法。 2、单继承，多实现。接口可以实现多个，但只能继承一个抽象类。 3、接口强调的是功能，抽象类强调的是所属关系。 4、接口中的所有成员变量 为public static final， 静态不可修改，当然必须初始化。接口中的所有方法都是public abstract 公开抽象的。而且不能有构造方法。抽象类就比较自由了，和普通的类差不多，可以有抽象方法也可以没有，可以有正常的方法，也可以没有。

- **transient**关键字对变量字段不进行序列化。
- **volatile**可以实现共享变量（内存）的可见性和防止指令重排序，无法保证原子性，保证可见性和有序性，常见的使用场景有多线程下的状态标记量和双重检查等。把值直接刷新到主内存中以及禁止重排序(没有数据依赖也不能优先编译)采用内存屏障StoreStore,StoreLoad,LoadLoad,LoadStore等
- ![img](https://cdn.nlark.com/yuque/0/2025/png/29188914/1758934555068-21fa103c-7f2f-4f78-b4c8-9443feff4fa5.png)
- java的import包就是一个路径，假设import java.util.Vector但是下面程序中并没有用到Vector那就不会装载这个类，只是告诉说如果用到这个类可以取util包找找。
- private变量/函数都是静态绑定，静态函数不能被override也是静态绑定，final也是静态绑定，final类不能被继承
- 接口interface中的变量一定是public static final，方法一定是public abstract抽象

## Collection

- **ArrayList**基于数组，**Linkedist**双向链表，arrayList随机访问，优于linkedlist
- 对于批量插入和删除，linkedlist会比Arraylist好，因为LinkedList不需要扩容/改变大小，不过消耗内存而已
- LinkedList占用内存比Arraylist多，因为Linkedlist还有2个引用，指向前与后
- 插入/删除用LinkedList，查询用ArrayList
- List单列数据集合，map双列数据集合，list先后顺序，set不允许重复元素
- Vector使用同步方法，线程安全
- ArrayList**自动扩容机制**ensureCapacityInternal，扩容1.5倍，Vector指定扩容或2倍，LinkedList不用扩容。
- 为什么使用**List list = new ArrayList<>(**)，使用List接口定义变量，好处是使代码更加灵活和可扩展，因为List是一个接口，它有多个实现类，如ArrayList，LinkedList。如果后续需要更换实现类只需要修改一行代码即可。另外，也可提高代码可读性和可维护性，List是常见的接口，其他开发人员可以很容易理解你的代码。
- String不可变，实现字符串池(String Pool)堆里，使多线程安全，避免安全问题url path，加快字符串处理速度hashcode唯一
- HashTable线程安全，使用synchronized保证线程安全。
- **HashMap**基于数组、链表和红黑树实现
- key不同比如'a'和97，但是hashCode值相同，index都是用97，所以使用链表(next)来解决
- JDK1.7中的HashMap扩容，容量为16，负载因子0.75，当容量超过因子与数组长度乘积时，扩容2倍。JDK1.8 HashMap引入红黑树，当某个哈希桶链表超过阈值(默认8)时，将链表转为红黑树，减少到6(默认)时又转回链表。
- HashMap存值过程：

- - 第一步：当往调用put方法向HashMap里增加一个键值对时，会先调用键的hashcode方法，来得到一个hashcode值，然后根据这个值来计算出这个键值对在map中数组对应的下标，及定位到HashMap中的具体的某一个桶。

```plain
public V put(K key, V value) {        
    */**四个参数，第一个hash值，第四个参数表示如果该key存在值，如果为null的话，则插入新的value，最后一个参数，在hashMap中没有用，可以不用管，使用默认的即可**/*        return putVal(hash(key), key, value, false, true);    
}

static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}

/**如果计算出的该哈希桶的位置没有值，则把新插入的key-value放到此处，此处就算没有插入成功，也就是发生哈希冲突时也会把哈希桶的首节点赋予p**/
if ((p = tab[i = (n - 1) & hash]) == null)
    tab[i] = newNode(hash, key, value, null);
//发生哈希冲突的几种情况
       else {
           // e 临时节点的作用， k 存放该当前节点的key 
           Node<K,V> e; K k;
           //第一种，插入的key-value的hash值，key都与当前节点的相等，e = p，则表示为首节点
           if (p.hash == hash &&
               ((k = p.key) == key || (key != null && key.equals(k))))
               e = p;
           //第二种，hash值不等于首节点，判断该p是否属于红黑树的节点
           else if (p instanceof TreeNode)
               /**为红黑树的节点，则在红黑树中进行添加，如果该节点已经存在，则返回该节点（不为null），该值很重要，用来判断put操作是否成功，如果添加成功返回null**/
               e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
           //第三种，hash值不等于首节点，不为红黑树的节点，则为链表的节点
           else {
               //遍历该链表
               for (int binCount = 0; ; ++binCount) {
                   //如果找到尾部，则表明添加的key-value没有重复，在尾部进行添加
                   if ((e = p.next) == null) {
                       p.next = newNode(hash, key, value, null);
                       //判断是否要转换为红黑树结构
                       if (binCount >= TREEIFY_THRESHOLD - 1) 
                           treeifyBin(tab, hash);
                       break;
                   }
                   //如果链表中有重复的key，e则为当前重复的节点，结束循环
                   if (e.hash == hash &&
                       ((k = e.key) == key || (key != null && key.equals(k))))
                       break;
                   p = e;
               }
           }
           //有重复的key，则用待插入值进行覆盖，返回旧值。
           if (e != null) { 
               V oldValue = e.value;
               if (!onlyIfAbsent || oldValue == null)
                   e.value = value;
               afterNodeAccess(e);
               return oldValue;
           }
       }
       //到了此步骤，则表明待插入的key-value是没有key的重复，因为插入成功e节点的值为null
       //修改次数+1
       ++modCount;
       //实际长度+1，判断是否大于临界值，大于则扩容
       if (++size > threshold)
           resize();
       afterNodeInsertion(evict);
       //添加成功
       return null;
```

- - 第二步：判断这个桶是否为空，如果是，直接把对象存到数组里，存储结束；如果不是，转到第三步
  - 第三步：判断已存在对象的key的equals方法，跟需要添加的对象的key对比，是否为true，如果是，覆盖这个key所对应的value，存储结束；如果不为true，转到第四步
  - 第四步：判断这个对象它指向下一个对象的next指针的是不是为空，如果不为空，重复第四步的过程；如果为空，则把该对象的next指针指向要增加的对象，存储结束。

- HashMap取值过程：

- - 第一步：调用key的hashcode方法，得到一个返回值，通过返回值定位到map中数组对应的下标，就是定位到HashMap中的具体的某一个桶。
  - 第二步：判断这个桶是否为空，如果是，就结束判断，返回null；如果不是空，就转到第三步。
  - 第三步：判断桶中对象的key值与传入的key值是否相等并且用equals方法判断他们是否为同一个对象，如果判断结果为真，就返回这个对象的value值；如果为假，就转到第四步。
  - 第四步：判断这个对象它指向下一个对象的next指针的是不是为空，如果是空，就结束判断，返回null；如果next指针不是空，就取出它所指对象，重复上面第三步的判断操作，直到取出对应的value值，或者直到桶中的对象被遍历完，返回一个null值。

- **HashMap**的遍历顺序是不确定的，如果需要保证顺序，可以用LinkedHashMap；如果并发需要保证线程安全，可以用ConcurrentHashMap。
- **HashMap**是**线程不安全**的，存在Entry链死循环和数据丢失的问题，使用红黑树解决。JDK8也存在put方法数据覆盖问题。
- **在JDK1.7 中，当并发执行扩容操作时会造成环形链和数据丢失的情况**； ② 在JDK1.8 中，在并发执行put操作的过程中，会出现数据覆盖的情况。
- 为什么**HashMap**使用红黑树而不是二叉树，因为二叉树可能会退化成链表，导致插入和查找时间复杂度变为O(N)，因为树没有平衡，而红黑树是一种自平衡的二叉搜索树，保证树的高度在较小的范围内，时间复杂度保持O(logN)
- Java1.7的**ConcurrentHashMap**内部使用Segment结构(分段锁)，每个Segment就是一个小的HashTable(HashEntry)，它定位一个元素需要进行两次hash，使用两次的hash构造分离锁，第一次Hash定位到segment，第二次hash定位到元素所在链表头部。java7主要采用锁机制，对某个segment进行操作时就锁定。Java1.8使用CAS无锁算法。
- ConcurrentHashMap中变量使用final确保初始化安全，让其不可变不需要同步就能共享。使用volatile可以保证某个变量内存的改变对其他线程可见，配合CAS可实现不加锁的并发操作。ConcurrentHashMap可以替代HashTable，引入了Segmentation分割，仅仅只需要锁定map的某个部分，其他线程依然可以访问map，而HashTable则会锁定整个map。
- ConcurrentHashMap缺陷：**严格来说读取操作不能保证反映最近的更新**。例如线程A调用putAll写入大量数据，期间线程B调用get，则只能get到目前为止已经顺利插入的部分数据。
- ConcurrentHashMap在JDK7和8区别：JDK8实现降低锁粒度，JDK7锁粒度基于Segment包含多个HashEntry，而JDK8锁粒度就是HashEntry(首节点)、JDK8数据结构更加简单，使用synchronized来进行同步，不需要分段锁概念，也就不需要Segment这种数据结构了、JDK8使用红黑树优化链表。

## JVM

- **Java类加载过程**：编译、加载（装载）、字节码验证、准备（分配内存）、解析、初始化、使用、卸载·
- **JVM分几个区域**：方法区、堆、栈、本地方法栈、程序计数器、垃圾回收。方法区和堆是线程共享的，栈、本地方法栈和程序计数器是线程私有的。
- **堆**：需要程序员自己申请并指明大小，以new Object()形式开辟，申请速度慢。栈是向低地址扩展的数据结构，是一块连续的内存区域。
- **栈**：由系统自动分配，自动为局部变量开辟一个空间比如int b，申请速度快。堆是向高地址扩展的数据结构，是不连续的内存区域。
- **栈内存**存储调用方法和局部变量。堆内存new创建对象、final变量
- 栈数据暂时存储的地方，一级缓存，先进后出原则；堆完全二叉树，二级缓存，手动分配和释放；是优先队列，先进先出原则
- **内存泄露**，一直没使用这个对象但是一直被引用，gc无法回收并释放。静态集合(List, Map等)引用导致内存泄露，始终存在，不会被垃圾回收。资源未正确关闭，比如数据库连接、文件等。匿名内部类持有外部类的引用。
- **内存溢出，堆溢出**：创建对象太多、单个对象占用内存过大。
- **栈溢出**：方法参数、局部变量参数过多，方法调用过深，导致栈空间耗尽时。
- 强引用Object strongReference = **new** Object();，当strongReference = **null**; jvm会认为该对象不存在引用了就会回收。
- 如果一个对象只具有**软引用**，则**内存空间充足**时，**垃圾回收器**就**不会**回收它；如果**内存空间不足**了，就会**回收**这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。
- **弱引用**与**软引用**的区别在于：只具有**弱引用**的对象拥有**更短暂**的**生命周期**。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有**弱引用**的对象，不管当前**内存空间足够与否**，都会**回收**它的内存。不过，由于垃圾回收器是一个**优先级很低的线程**，因此**不一定**会**很快**发现那些只具有**弱引用**的对象。
- **虚引用**顾名思义(PhantomReference)，就是**形同虚设**。与其他几种引用都不同，**虚引用**并**不会**决定对象的**生命周期**。如果一个对象**仅持有虚引用**，那么它就和**没有任何引用**一样，在任何时候都可能被垃圾回收器回收。
- 引用ref: https://juejin.cn/post/7075893982953209887
- **垃圾回收算法**：标记清除法（遍历标记然后清除）、标记整理法（遍历标记然后移动）、复制复法（分为两个大小相等的两块，一块使用完了就将存活的对象移到另一块）、分代收集算法
- **垃圾回收器**：Serial单线程收集器（复制算法）、ParNew Serial的多线程版本、Parallel Scavenge 并发的多线程（复制算法）、CMS、G1服务端模式的垃圾回收器，标记整理算法与复制算法，先标记然后更新Region的回收价值与成本进行排序，复制存活对象，清理旧Region，需要暂停用户线程
- GC通过引用计数法来记录当前引用计数器是否为0，0则被回收。GC通过判断是否可达来确定其是否需要被回收，当一个对象不可达时，垃圾回收器会标记为可回收对象。
- GC Roots是保持对象存活的根节点，主要包括：虚拟机栈中的引用(局部变量和参数等)、静态变量、常量池中的引用、调用本地方法的引用、基本数据类型的类对象、常驻性类的引用等。
- Young GC(Minor)，有Eden区，"FROM"Survivor区，"TO"Survivor区，当Eden区满了，会执行复制算法，把from丢到to区，如果在Survivor区熬过一次Minor GC就会将对象年龄+1，直到15岁时还没GC就会丢到老年代
- Old GC(Major) 老年代
- Perm GC(永久代)，jdk8后被替换为元空间metaspace，方法区，使用本地内存。它用于存储类的元信息、静态变量、常量池。好处：动态调整大小、垃圾回收效率高，只回收必要的类和常量、本地内存。**类的元数据放入native memory,字符串池和类的静态变量放入java堆**中
- Full GC触发条件：老年代空间不足，方法区空间不足，类卸载，minor gc时往老年代放的存放的对象大小大于老年代连续区块大小，则会full gc。
- GC ref: [https://www.yishuifengxiao.com/2022/02/22/JVM%E4%B8%ADGC%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/](https://www.yishuifengxiao.com/2022/02/22/JVM中GC的基本概念/)
- 静态变量存放在方法区中，不放在堆或栈中。
- **JVM双亲委派模型**：启动类加载器、扩展类加载器、应用程序类加载器、自定义类加载器。先请求父类加载器去加载，如果父类无法加载再尝试自己去加载类，如果都没加载就抛出异常。
- **启动类加载器**：JAVA_HOME/jre/lib中加载、扩展类加载器：JAVA_HOME/jre/lib/ext中加载、应用程序类加载器：CLASSPATH中加载。
- 为什么不能定义java.lang.Object文件，因为已经被启动类加载器加载了。
- 为什么**JVM**要使用**双亲委派模型**加载类，避免用户编写类动态替换Java核心类，性能：避免重复加载，安全：避免核心类被修改。
- loadClass逻辑：首先加锁，防止多线程，重复加载一个类，加载类时会请求父类加载器去加载类，如果父类无法则自己加载。
- 如何**破坏双亲委派模型**：使用父类调用子类加载器去加载类。
- Class.forName()：保证Java类加载到内存中，类默认会被初始化，默认会使用当前类加载器来加载对应的类。Class.forName("com.mysql.jdbc.Driver")应用程序类加载器加载。
- ClassLoader.loadClass()：是启动类加载器进行加载，类不会被初始化，类会被加载到内存中，可以实现自定义的类加载器。

## 线程

- 创建线程方法：继承Thread类，重写run方法；实现Runnable接口，重写run方法；实现Callable接口，重写call方法，有返回值，使用FutureTask来配合实现，把实现Callable的类丢进去

```plain
Callable<String> myCallable = new MyCallable();
    FutureTask<String> oneTask = new FutureTask<String>(myCallable);
    Thread t = new Thread(oneTask);
        t.start();
```

- Runnable 接口 run 方法无返回值；Callable 接口 call 方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果
- Runnable 接口 run 方法只能抛出运行时异常，且无法捕获处理；Callable 接口 call 方法允许抛出异常，可以获取异常信息
- **线程上下文加载器ThreadContextClassLoader**：可以让父类加载器通过调用子类加载器去加载类。
- **孤儿进程**：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。
- **僵尸进程**：一个进程使用fork创建子进程，如果子进程要退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，并没有子进程要退出的状态信息，那么子进程仍然保存在系统中，占用系统内存资源。
- **抽象类**：提供成员方法，成员变量各种类型，可以有static，一个类可以继承一个抽象类，不能final,模板式设计
- **接口类**：只能public abstract方法，成员变量只能public static final，不能有static，一个类实现多个接口，辐射式设计
- `**newSingleThreadExecutor**`：创建一个单线程的线程池，任务按提交顺序执行。
- `**newFixedThreadPool**`：创建一个固定大小的线程池，限制并发线程数。
- `**newCachedThreadPool**`：创建一个可缓存的线程池，线程池大小不受限制，适用于大量短期任务。空闲线程会被收回
- `**newScheduledThreadPool**`：创建一个支持定时及周期性任务执行的线程池。
- `**newSingleThreadScheduledExecutor**`：创建一个单线程的调度线程池，支持定时及周期性任务执行，任务按顺序执行。

## 锁

- **CAS**是一种无锁算法，乐观锁，CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。

```plain
class AtomicInteger { 
 
    private volatile int value;
 
    public int getAndIncrement() {
        int oldValue = value;
            while ( CAS(value, oldValue, oldValue+1) != true) { 
               oldValue = value;
            }
        return oldValue;
    }
}

boolean compareAndSwap(int expectedValue, int newValue) {
    // 读取当前值
    int currentValue = value;
    
    // 比较当前值与期望值是否相同
    if (currentValue == expectedValue) {
        // 如果相同，则更新为新值
        value = newValue;
        return true;
    } else {
        // 如果不同，不更新
        return false;
    }
}
```

- **CAS的ABA问题**，可能出现的场景是，张某存款100，本来从ATM取了50，有两个线程去执行CAS，正常会一个成功，一个失败，因为比较旧值的时候不一样，但是如果第一线程执行完后-50了，有人突然转钱给张某+50（内存50，期望100），变回原值100，第二个线程在比较的时候不会失败因为判断到旧值与内存值一样，又扣款了50，所以出现ABA问题。**解决方案**：添加版本号，判断值的同时也要判断版本号。
- 多线程问题：线程安全（原子性、可见性、有序性），活跃性（死锁、活锁、饥饿），性能问题（创建线程开销、线程上下文切换（CAS算法））
- 并发三性，可见性、原子性、有序性
- synchronized重量级锁加在static方法就使用类名.class，不然就使用this
- 线程实现同步保证安全性问题，synchronized锁，偏向锁、轻量锁、重量锁，Lock锁(JUC)底层基于AQS和CAS实现，不属于重量级锁，使用ThreadLocal，缓存局部变量，不会有共享就不会有线程安全问题，注意内存泄露问题，实现CAS。
- synchronize是关键字，ReentrantLock是一个类，synchronized是隐式取锁（偏向锁->轻量级->重量级)，当线程进入synchronized代码块或方法时，会自动取锁，并在代码块或方法执行完毕后释放锁。而ReentrantLock需要显式地调用lock()方法取锁并在合适时调用unlock释放锁。synchronized是可重入锁，同一个线程可以多次获取同一个锁而不会造成死锁，ReentrantLock也是可重入锁，重量级锁，并提供更多高级特性，比如可中断、公平锁等。synchronized锁粒度比较粗，一次只能锁住一个代码块或方法，而ReentrantLock可以根据需要灵活地进行锁定，可以在代码中任何位置上锁。在低并发情况，synchronized比ReentrantLock性能好，因为synchronized是由JVM底层实现，而ReentrantLock是通过代码实现，但在高并发情况，ReentrantLock性能更好，因为它提高更多调优选项。ReentrantLock默认非公平。

![img](https://cdn.nlark.com/yuque/0/2025/png/29188914/1759020027285-4ab33a46-5f3f-42c0-910e-042e5ed55c0e.png)

- **公平锁**：保证顺序，避免饥饿，适合 **队列型、顺序敏感** 的业务。
- **非公平锁（默认）**：性能更高，适合 **高并发、大吞吐量** 的业务。

- ThreadLocal表示线程的局部变量，确保每个线程的ThreadLocal变量都是各自独立的，适用于存储和传递上下文信息，需要使用try...finally结构，并在finally清除。
- @Scope(value = "prototype")原型注解使单例变成多例，使用synchronized锁的话就会使用不同的this，不会造成单线程一直等待锁。
- **wait和notify**需要放到Synchronized代码块中使用的，**wait**会释放锁进入等待状态，需要通过notify唤醒，sleep主要是线程暂停，不会释放锁。
- Java实现**线程通信**的方式有两种：利用**Monitor**和利用**Condition**，当线程使用synchronize关键字进行线程同步时，使用Monitor来调用wait、notify、notifyAll进行线程通信；当线程使用Lock对象来实现线程同步时，使用Condition并调用相关的await、sign、signAll方法来实现线程通信。
- 数据库死锁 - SHOW ENGINE INNODB STATUS

## Spring

- Spring框架，轻量、控制反转、AOP面向切面编程、容器、MVC框架、事务管理、异常处理
- Spring Bean生命周期 实例化、属性赋值、初始化、销毁
- 依赖注入：构造函数注入、setter注入、接口注入
- Bean Factory作用是管理Bean，即实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。
- Bean Factory优点：启动时占用资源少，缺点：运行速度相对来说慢一点，可能出现空指针异常
- ApplicationContext优点：所有Bean在启动时进行了加载，系统运行速度快，缺点：内存占用较大
- 为什么要定义一个Service接口和一个Service实现类，因为要实现低耦合、可扩展、可测试和易于维护的代码结构。

### AOP

- AOP：比如在两个类中，每个方法都需要做日志，那有没有办法在需要时随意地加入代码，就通过AOP在运行时动态地将代码切入到类的指定方法、指定位置。织入，运行时生成代理对象来织入，也可议在编译期、类加载期织入。应用场景包括日志记录、事务管理、安全性检查、性能监控。
- AOP面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。AOP是[OOP]的延续。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的[耦合度]降低，提高程序的[可重用性]，同时提高了开发的效率。**日志记录、权限校验、事务管理、性能监控**。比如写Controller API时，如果有AOP的话，需要在每个方法都加一遍权限校验代码。
- Spring AOP采用动态代理，有JDK动态代理何CGLIB动态代理。**Spring AOP 动态代理 = 运行时生成一个代理对象，在方法执行前后织入额外逻辑。**

| 代理方式           | 触发条件         | 底层技术                  | 类图特征           |
| ------------------ | ---------------- | ------------------------- | ------------------ |
| **JDK 动态代理**   | 目标类有实现接口 | `java.lang.reflect.Proxy` | 代理对象是接口类型 |
| **CGLIB 动态代理** | 目标类没实现接口 | 字节码生成（继承目标类）  | 代理对象是子类类型 |

```java
// Spring 会在运行时生成一个 实现了 UserService 接口的代理类：
UserService proxy = Proxy.newProxyInstance(
    UserService.class.getClassLoader(),
    new Class[]{UserService.class},
    (proxyObj, method, args) -> {
        System.out.println("开启事务");
        Object result = method.invoke(new UserServiceImpl(), args);
        System.out.println("提交事务");
        return result;
    }
);
// Spring 就会用 CGLIB 动态生成一个继承自 OrderService 的子类：
class OrderService$$EnhancerBySpringCGLIB extends OrderService {
    @Override
    public void createOrder() {
        System.out.println("开启事务");
        super.createOrder();
        System.out.println("提交事务");
    }
}
```

简单来说就是把一些通⽤的功能从业务代码⾥抽取出来，统⼀处理。

如果需要自己写注解然后实现动态代理，需要加上@Aspect

```java
// 自己写的注解
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyLog {
}

// Spring切面动态代理
@Aspect
@Component
public class MyLogAspect {

    @Pointcut("@annotation(com.example.MyLog)")
    public void logPointcut() {}

    @Around("logPointcut()")
    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println("方法开始前打印日志");
        Object result = joinPoint.proceed();
        System.out.println("方法结束后打印日志");
        return result;
    }
}
```

### Spring IOC

- Spring IOC(Inversion of control控制反转)：用于解耦和管理对象的依赖关系。对象的创建和依赖关系的管理被转移到了容器（Container）中。容器负责创建对象、解决对象之间的依赖关系，并将这些对象交给应用程序使用。只需要通过配置或注解来描述对象及其依赖关系，由容器负责实际的对象创建和依赖注入。面向接口编程实现松耦合。
- Spring通过`IoC`（Inversion of Control，控制反转）容器实现依赖注入。可以使用构造函数注入、属性注入（setter注入）和注解（如`@Autowired`、`@Inject`）来实现依赖注入。通过`@Component`、`@Service`、`@Repository`等注解，Spring会自动将这些类注册为Spring容器的Bean。在Spring Boot中，`@Autowired`是最常用的注入方式，构造函数注入也被推荐，因为它可以确保对象初始化时所有的依赖都是可用的。

```plain
Spring IOC初始化步骤
1：配置文件加载 ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
2：加载 BeanDefinition
    使用 BeanDefinitionReader 解析 XML/注解/JavaConfig。
    把 bean 的信息（class、scope、依赖等）封装成 BeanDefinition，注册到 BeanDefinitionRegistry（通常是 DefaultListableBeanFactory）。
3：实例化与依赖注入
    refresh() 方法触发 BeanFactoryPostProcessor → BeanPostProcessor → 实例化 Bean → 属性注入 → 初始化方法调用 → 放入单例池

@Override
public void refresh() throws BeansException {
    synchronized (this.startupShutdownMonitor) {
        // 1. 创建 BeanFactory（底层用 DefaultListableBeanFactory）
        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

        // 2. BeanFactory 的准备工作（注册系统 bean，比如 environment 等）
        prepareBeanFactory(beanFactory);

        // 3. 调用 BeanFactoryPostProcessor（修改 BeanDefinition）
        invokeBeanFactoryPostProcessors(beanFactory);

        // 4. 注册 BeanPostProcessor（影响 Bean 实例化）
        registerBeanPostProcessors(beanFactory);

        // 5. 初始化消息源、事件、多播器
        initMessageSource();
        initApplicationEventMulticaster();

        // 6. 实例化剩余的非延迟加载的单例 bean
        finishBeanFactoryInitialization(beanFactory);

        // 7. 完成 refresh，发布容器事件
        finishRefresh();
    }
}

流程简化图
1. 加载配置 → Resourcec
2. 解析配置 → BeanDefinition
3. 注册 BeanDefinition → BeanFactory
4. 实例化 Bean → 依赖注入（DI）
5. BeanPostProcessor 回调 → AOP 等增强
6. 放入单例池 → 提供给外部使用
```

### Bean vs Component

![img](https://cdn.nlark.com/yuque/0/2025/png/29188914/1759019723585-54e3bd85-d162-4d29-a7e3-ebba81299b80.png)

### Controller vs Service vs Component vs Repository

- `@Controller` → Web 层（处理 HTTP 请求），`**@Controller**` 的类，Spring MVC 会扫描它的方法上的 `@RequestMapping`、`@GetMapping`、`@PostMapping` 等注解；  
- `@Service` → 业务逻辑层
- `@Repository` → 数据访问层， Spring 对 `@Repository` 做了一个 **特殊增强**：
  👉 **自动把底层数据库异常（如 JDBC、Hibernate 异常）转换成 Spring 的统一异常体系** `**DataAccessException**`**。**
- `@Component` → 其他通用组件（如工具类、监听器、拦截器等）

### BeanFactory vs FactoryBean

`BeanFactory` 是 **Spring IoC 容器的顶层接口**，负责管理、创建、获取 Bean。

```java
public interface BeanFactory {
    Object getBean(String name) throws BeansException;
    <T> T getBean(Class<T> requiredType) throws BeansException;
    // ...
}
```

作用：

- 提供 **Bean 的生命周期管理**：创建、依赖注入、销毁。
- 是 Spring 的 **核心容器机制**。
- `ApplicationContext` 是它的子接口，功能更强（比如国际化、事件发布、资源加载等）。

`FactoryBean` 是什么？**它是用户自定义的 Bean 工厂**，可以控制某个 Bean 的创建逻辑。是一个 **接口**，让你自己定义 Bean 的创建逻辑。

```java
public interface FactoryBean<T> {
    T getObject() throws Exception;     // 返回要创建的 Bean
    
    Class<?> getObjectType();           // 返回 Bean 类型
    
    default boolean isSingleton() {     // 是否单例
        return true;
    }
}
```

**举例：**

假设你想控制某个复杂对象（例如第三方连接）的创建过程：

```java
@Component
public class MyConnectionFactoryBean implements FactoryBean<Connection> {
    @Override
    public Connection getObject() throws Exception {
        return DriverManager.getConnection("jdbc:mysql://localhost/test");
    }

    @Override
    public Class<?> getObjectType() {
        return Connection.class;
    }

    @Override
    public boolean isSingleton() {
        return true;
    }
}
```

使用时：

```java
@Autowired
private Connection connection; // 实际注入的是 FactoryBean.getObject() 返回的对象
```

**特点：**

- `FactoryBean` 本身也是一个 Bean；
- 它返回的对象是通过 `getObject()` 创建的；
- 想获取它本身而不是它创建的对象，可以用 `&` 前缀：

```plain
factory.getBean("&myConnectionFactoryBean"); // 获取 FactoryBean 自身
factory.getBean("myConnectionFactoryBean");  // 获取 getObject() 返回的对象
```

### Interceptor拦截器

 Spring 常见的 5 大“拦截链”组件（`Filter`、`HandlerInterceptor`、`AOP`、`ResponseBodyAdvice`、`ControllerAdvice`）。

```java
请求进入 →
   ↓
[Filter]               （最先执行，Servlet 层）
   ↓
[HandlerInterceptor.preHandle()]
   ↓
[Controller 方法执行]   （业务逻辑）
   ↓
[AOP 切面 @Around()]
   ↓
[HandlerInterceptor.postHandle()]
   ↓
[ResponseBodyAdvice.beforeBodyWrite()]
   ↓
[HandlerInterceptor.afterCompletion()]
   ↓
[ControllerAdvice 异常处理] （如果有异常）
```

| 拦截器类型                              | 层级           | 接口 / 注解                     | 典型用途             |
| --------------------------------------- | -------------- | ------------------------------- | -------------------- |
| **Filter**                              | Servlet 层     | `Filter`                        | 编码、跨域、日志     |
| **HandlerInterceptor**                  | MVC 层         | `HandlerInterceptor`            | 登录校验、日志、权限 |
| **WebRequestInterceptor**               | MVC 层         | `WebRequestInterceptor`         | 旧版支持             |
| **HandlerMethodArgumentResolver**       | 参数解析层     | `HandlerMethodArgumentResolver` | 自动注入用户对象     |
| **AOP 切面**                            | 方法层         | `@Aspect`                       | 日志、事务、监控     |
| **ResponseBodyAdvice**                  | 响应层         | `ResponseBodyAdvice`            | 统一包装返回         |
| **ControllerAdvice / ExceptionHandler** | 异常层         | `@ControllerAdvice`             | 统一异常处理         |
| **HandlerExceptionResolver**            | MVC 底层       | `HandlerExceptionResolver`      | 框架级异常处理       |
| **Spring Security Filter Chain**        | 安全层         | 一系列 Filter                   | 权限控制、JWT 验证   |
| **WebFilter / WebHandlerInterceptor**   | 响应式 WebFlux | 对应接口                        | 异步拦截逻辑         |

### 事务

@Transactional，Spring 的事务是通过 **AOP 代理机制** 实现的：当一个类或方法被标注 `@Transactional` 时，Spring 会在该 Bean 外面包一层 **代理对象（Proxy）**；调用代理对象的方法时，Spring 会在方法前后自动执行：

1. `开启事务`
2. `执行目标方法`
3. `提交或回滚事务`

**事务异步化**

让异步逻辑参与事务  @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)

Spring 在启动时，会扫描所有被：

- `@EventListener`
- `@TransactionalEventListener`

标注的方法，然后注册到内部的：

```
ApplicationEventMulticaster
```

当你调用 `publishEvent()` 时，Spring 会：

1. 遍历所有监听器；
2. 判断监听方法参数类型是否是事件类型的父类或相同；
3. 若匹配 → 调用该监听方法。

| 匹配机制     | 说明                    | 示例                                            |
| ------------ | ----------------------- | ----------------------------------------------- |
| 参数类型匹配 | 事件类型 = 方法参数类型 | `UserCreatedEvent` → `handle(UserCreatedEvent)` |
| 继承匹配     | 事件是父类的子类        | `BaseEvent` → `handle(BaseEvent)`               |
| 条件匹配     | 使用 SpEL 表达式        | `@EventListener(condition="#event.x>10")`       |
| 泛型匹配     | 支持带泛型的事件        | `EntityCreatedEvent<User>`                      |

**事务失效场景**

| 场景                                  | 原因                         | 示例                              |
| ------------------------------------- | ---------------------------- | --------------------------------- |
| **1. 自调用（同类方法内部调用）**     | 调用未经过代理对象           | `this.methodB()` 不触发事务       |
| **2. 方法不是 public**                | AOP 只能代理 public 方法     | `private void doSomething()`无效  |
| **3. 异常被捕获后未重新抛出**         | Spring 无法感知异常          | `catch`后未 `throw`，事务不会回滚 |
| **4. 异常类型不匹配**                 | 默认只回滚 RuntimeException  | 抛出 `CheckedException`不会回滚   |
| **5. 没有被 Spring 管理的 Bean 调用** | 没有代理对象参与             | `new ServiceImpl().method()`无效  |
| **6. 多线程调用 / 异步调用**          | 新线程不在同一事务上下文     | `@Async`、`new Thread()`会失效    |
| **7. 调用时机太早**                   | 例如在构造函数中调用事务方法 | Bean 未完全代理化                 |
| **8. Propagation 配置不当**           | 不同传播行为影响结果         | 如外层事务 REQUIRES_NEW 或 NEVER  |

**事务传播行为 Propagation**

| 传播行为             | 含义                         | 是否复用外层事务   | 外层无事务时的行为 |
| -------------------- | ---------------------------- | ------------------ | ------------------ |
| **REQUIRED**（默认） | 有事务就加入，没有就新建     | ✅ 是               | 🔹新建一个事务      |
| **REQUIRES_NEW**     | 总是新开事务，暂停外层       | ❌ 否               | 🔹新建一个事务      |
| **NESTED**           | 嵌套事务（保存点）           | ✅ 是（保存点方式） | 🔹新建一个事务      |
| **SUPPORTS**         | 有事务就加入，没有就不用事务 | ✅ 是               | 🚫 不开事务         |
| **NOT_SUPPORTED**    | 有事务就挂起，不用事务       | 🚫 否               | 🚫 不开事务         |
| **MANDATORY**        | 必须有外层事务，否则抛异常   | ✅ 是               | ❌ 抛异常           |
| **NEVER**            | 禁止在事务中运行             | 🚫 否               | ✅ 正常运行         |

长事务

- **锁保持太久 → 阻塞其他事务**
- **容易出现****锁等待****、****死锁****、****性能抖动**
- **占用数据库连接资源**
- **回滚成本高**
- **难以保证一致性（分布式系统中），涉及外部系统调用**  
- **性能下降 & 并发降低**  

### Spring vs SpringBoot

1. **Spring 是一个功能丰富的企业级开发框架，提供了灵活的组件和配置方式。**
2. **Spring Boot 是基于 Spring 的快速开发工具，提供自动配置和内嵌服务器，简化了项目搭建和部署流程。**自动配置就是：你引了什么依赖 + 配了什么属性，它就自动帮你创建相应的 Bean
3. **相比传统 Spring，Spring Boot 更适合快速构建微服务和现代应用。**

分布式系统中，CAP，存在**Consistency（一致性）、Availability（可用性）、Partition tolerance（分区容错性）**，三者不可同时保证，最多只能保证其中的两者。

Spring vs SpringBoot vs SpringCloud

![img](https://cdn.nlark.com/yuque/0/2025/png/29188914/1759019402117-5c9ddc53-2f65-452b-b9b0-62a385ced859.png)

**AC 可用性+一致性**要同时保证可用性和一致性，代表着某个节点数据更新之后，需要立即将结果通知给其他节点，并且要尽可能的快，这样才能及时响应保证可用性，这就对网络的稳定性要求非常高，但是实际情况下，网络很容易出现丢包等情况，并不是一个可靠的传输，如果需要避免这种问题，就只能将节点全部放在一起，但是这显然违背了分布式系统的概念，所以对于我们的分布式系统来说，很难接受。

**CP 一致性+分区容错性**为了保证一致性，那么就得将某个节点的最新数据发送给其他节点，并且需要等到所有节点都得到数据才能进行响应，同时有了分区容错性，那么代表我们可以容忍网络的不可靠问题，所以就算网络出现卡顿，那么也必须等待所有节点完成数据同步，才能进行响应，因此就会导致服务在一段时间内完全失效，所以可用性是无法得到保证的。

**AP 可用性+分区容错性**既然CP可能会导致一段时间内服务得不到任何响应，那么要保证可用性，就只能放弃节点之间数据的高度统一，也就是说可以在数据不统一的情况下，进行响应，因此就无法保证一致性了。虽然这样会导致拿不到最新的数据，但是只要数据同步操作在后台继续运行，一定能够在某一时刻完成所有节点数据的同步，那么就能实现最终一致性，所以AP实际上是最能接受的一种方案。

## SpringBoot

- Spring Boot特性 自动配置 起步依赖 命令行界面 无代码生成和xml配置 自带应用监控

## SpringCloud

- Spring Cloud: 网络 - 进入网关然后nginx转发 - 注册中心和apollo配置中心，再到对应的服务，还有中间件Redis mysql mq等。
- 微服务的核心组件包括：服务注册与发现consul、负载均衡Ribbon、服务网关gateway、配置中心apollo、断路器hystrix等。
- 微服务好处：加快可扩展性、高可用性、缩短部署时间、改善故障隔离、提高团队工作效率、提高成本效益；坏处：系统开销大

## 设计模式

**设计模式：创建型模式、结构性模式、行为型模式**

- 创建型模式：包括单例、原型、工厂方法、抽象工厂和建造者模式。
- 结构型模式：包括适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
- 行为型模式：包括策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

### 创建型模式

#### 单例模式：

保证一个类只有一个实例，并且提供一个访问该全局访问点。应用在网站计数器、应用程序日志、多线程的线程池设计、Windows的任务管理器(Task Manager)，创建方式：饿汉式(类初始化就加载该对象，线程安全)、懒汉式(类初始化不会初始化该对象，真正需要时才会加载)

#### 工厂模式

创建者与调用者分离，模式分为简单工厂（静态方法，根据外界给的信息决定创建那个具体类对象）、工厂方法（多态，子类来完成具体的产品类型）、抽象工厂（一个总工厂有不同的子工厂，子工厂来提供多个产品）。使用工厂设计模式创建Bean，创建后存放到Map中，不会重复。

- 简单工厂：一个abstract类，多个类区继承它，解耦各部分，比如abstract Operation, 然后又OperationAdd, OperationSub等等，然后加一个class Factory和方法createProduct(Type)，构建Operation (去选择哪个Product)
- 工厂方法：4个角色，抽象产品(IProduct), 具体产品(Product), 工厂接口(IFactory), 工厂实现(Factory)，比如说AddFactory只创建OperationAdd的产品，不做其他的。符合开闭原则。
- 抽象工厂：角色，抽象工厂(AbstractFactory), 具体工厂(ConcreteFactory), 抽象产品(AbstractProduct), 具体产品(ConcreteProduct), Client(客户端), 工厂都可以创建同样的产品，比如有ProductA和ProductB，那么如果有两个工厂Factory1, Factory2，那么就会有4中产品，比如ProductA1, ProductA2, ProductB1, ProductB2。

- - 参考：https://juejin.cn/post/6844904187222818824

#### 建造者模式：

将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象，对象内部属性相互依赖。关注于零件装配的顺序。

#### 原型模式：

克隆，复制一个已存在的实例可使程序更高效。浅拷贝：只是拷贝基本类型的数据，而引用类型数据则拷贝引用地址。深拷贝：在计算机开辟一块新的内存地址用于存放复制的对象。

### 结构型模式

#### 外观模式：

隐藏系统的复杂性，向客户端提供一个客户端可以访问系统的接口。把接口和实现类都放入一个类中的方法去实现，然后只需要调用这个方法就能实现隐藏的接口方法。

#### 观察者模式：

又叫发布-订阅模式，定义对象之间一种一对多的依赖关系，当一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。主要用于1对N的通知。

#### 代理模式：

静态代理：由程序员创建或工具生成代理类的源码，在编译代理类，静态是在程序运行前就已存在代理类。通过代理类实现接口类。动态代理：JDK代理、接口代理，利用JDK的API，动态的在内存构建代理对象

在代理模式中，有三个关键角色：

**抽象主题（Subject）：**定义了代理类和真实主题的共同接口。这个接口可以是一个抽象类或接口，它声明了客户端可以使用的方法。

**真实主题（Real Subject）：**定义了代理类所代表的真实对象。也就是说，它是客户端最终想要访问的对象。真实主题类实现了抽象主题接口，提供了具体的业务逻辑。

**代理（Proxy）：**代理持有对真实主题的引用，并提供与真实主题相同的接口，以便于客户端访问。代理类可以在客户端访问真实主题之前或之后执行额外的操作，例如记录日志、控制访问权限等。代理类与真实主题之间的关系通常是关联关系，即代理类中含有一个真实主题对象的引用。

### **行为型模式**

#### 策略模式：

定义了一系列的算法或逻辑或相同意义的操作，并将每一个算法、逻辑、操作封装起来，使他们可以相互替换。比如支付策略方式(vx/zfb/银行)

策略模式包含以下关键点（也就是上面我们提到的三个关键角色）：

- 定义算法接口：首先，我们定义一个算法接口或抽象类，其中声明了算法的方法。这个接口或抽象类通常称为策略接口。
- 具体算法实现：针对算法接口，我们可以有多个具体的算法实现类，每个实现类都实现了策略接口中定义的方法，并提供了自己的算法逻辑。
- 上下文：上下文是使用算法的类或对象，它持有一个指向策略接口的引用。在需要执行算法的时候，上下文对象调用策略接口中的方法来委托给具体的算法实现类。

#### 模板方法模式：

定义一个操作中的算法骨架，而将一些步骤延迟到子类中。实现一些操作时，整体步骤固定，但是其中一小部分需要改变。比如去餐厅吃饭，菜单、点菜、吃饭、付款、走人步骤，点菜和付款方法不确定则让子类来完成。

### 策略和代理模式

代理模式 (Proxy Pattern): 代理模式涉及到一个代理类（Proxy）和一个实际目标对象（Real Subject）。代理类通常具有与目标对象相同的接口，代理类的主要作用是在访问实际目标对象之前或之后添加一些**额外功能，例如缓存、权限控制、日志记录**等。代理模式分为几种类型，如静态代理、动态代理和远程代理等。

代理模式的关注点是如何在不改变实际目标对象的基础上添加额外功能，这有助于实现关注点的分离。

2.策略模式 (Strategy Pattern): 策略模式涉及到一个上下文类（Context），一个策略接口（Strategy）以及实现策略接口的一组具体策略类（Concrete Strategies）。策略模式的主要目的是将一组相关算法封装到一系列策略类中，使它们可以互相替换，并让客户端代码可以根据需要选择合适的策略。策略模式有助于将算法的定义和使用分离，提高代码的可扩展性和可维护性。

策略模式的关注点是如何在运行时根据需求动态地选择合适的算法或行为。

总结一下，代理模式关注的是如何在访问实际目标对象时添加额外功能，而策略模式关注的是如何在运行时动态地选择合适的算法或行为。代理模式主要解决的问题是关注点的分离，而策略模式主要解决的问题是算法和行为的可替换性和扩展性。

## 设计原则

- OOP设计原则：单一职责原则 (Single Responsibility Principle)、开放-封闭原则 (Open/Closed Principle)、里氏替换原则 (Liskov Substitution Principle)、接口隔离原则 (Interface Segregation Principle)、依赖倒置原则 (Dependency Inversion Principle)、组合优于继承 (Composition over Inheritance)
- **单一职责原则（SRP，Single Responsibility Principle）**：

- - 每个类只负责一项职责或功能。类的更改只应源于其职责的变化。
  - 目的：减少类的复杂性，使类更专注和容易维护。
  - 例如，一个类如果同时处理业务逻辑和数据访问逻辑，可以考虑将其拆分为两个类，分别处理这些职责。

- **开闭原则（OCP，Open/Closed Principle）**：

- - 软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。
  - 目的：允许在不修改现有代码的情况下扩展功能，避免因修改引入新的错误。
  - 例如，通过接口或抽象类进行扩展，而不修改现有的实现类。

- **里氏替换原则（LSP，Liskov Substitution Principle）**：

- - 子类应该可以替换父类，并且不改变程序的行为。
  - 目的：确保继承关系的合理性，子类应该增强父类的行为，而不是破坏它。
  - 例如，如果子类重写了父类的方法，子类的方法应该能够无缝替换父类的方法。

- **接口隔离原则（ISP，Interface Segregation Principle）**：

- - 应该为客户端提供细化的接口，而不是一个大的、笼统的接口。
  - 目的：避免客户端依赖它不需要的接口方法。
  - 例如，将大型接口分解为多个小的、专注于特定功能的接口，客户端可以根据需要实现相关接口。

- **依赖倒置原则（DIP，Dependency Inversion Principle）**：

- - 高层模块不应该依赖于低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。
  - 目的：减少模块间的耦合性，通过依赖接口或抽象来降低对具体实现的依赖。
  - 例如，高层业务逻辑应该依赖于接口或抽象类，而不是具体的实现类。

## 其他

- SkipList，通过索引层级，使用空间换时间的概念，方便查询O(logN)

![img](https://cdn.nlark.com/yuque/0/2025/jpeg/29188914/1758934553706-ccff0f68-86f1-4580-aac6-3a11c97dbef2.jpeg)

# 中间件

## RPC

- 远程调用，即在微服务/分布式服务之间的调用，RPC是应用层调用，而HTTP是协议通信层，RPC可以基于HTTP协议也可以不用，也可以有自己的协议，但传输层基本基于TCP，但RPC也可以有自己定义的TCP。
- RPC 底层传输逻辑就是：**把方法调用“变成字节流”，通过网络发出去，然后“再变回来”**，整个过程对开发者是透明的。

| **层级**           | **说明**                         | **示例**                       |
| ------------------ | -------------------------------- | ------------------------------ |
| 应用层（调用）     | **RPC 调用：方法级通信**         | `userService.getUserById(123)` |
| 协议层（通信协议） | **RPC 协议、HTTP 协议等**        | Protobuf、HTTP、Dubbo协议      |
| 传输层（底层）     | **传输数据的方式（一般是 TCP）** | TCP、QUIC、UDP                 |

## MQ



# 系统设计

## 加解密

### 登录密码

登录密码设计，hash = md5(password + salt)

注册时，
1）用户提供密码（以及其他用户信息）；
2）系统为用户生成Salt值；
3）系统将Salt值和用户密码连接到一起；
4）对连接后的值进行散列，得到Hash值；
5）将Hash值和Salt值分别放到数据库中。

登陆时：

1）用户提供用户名和密码；
2）系统通过用户名找到与之对应的Hash值和Salt值；
3）系统将Salt值和用户提供的密码连接到一起；
4）对连接后的值进行散列，得到Hash'（注意有个“撇”）；
5）比较Hash和Hash'是否相等，相等则表示密码正确，否则表示密码错误。

### 非对称加密

公钥加密，私钥解密

发送者使用接收者的公钥加密，只有接收者自己的私钥能解密这份数据

RSA

### 签名

私钥签名，公钥验证

发送者使用私钥签名，接收者使用公钥验证发送者身份。

### 对称加密

AES

## 如何避免同时点击

两个线程进来，如何避免同个'位置'被同时选择并且占用

- select for update 行锁
- select by version 版本号控制，update时也要是同个版本号才能更新成功
- 状态机

# 数据库

- **数据库三范式**：第一范式（列不可再分。对属性原子性约束），**第二范式**（行可以唯一区分，主键约束，唯一性约束，每个表只描述一件事），**第三范式**（表的非主属性不能依赖与其他表的非主属性，外键约束，比如用户姓名在Orders表里是没必要的，冗余性约束）
- 数据库的事务有**四大特性**：**原子性**（事务不可分的，不能被干扰，要么全部做完，要么全部失败）、**一致性**（事务完成，数据必须一致）、**隔离性**（对数据进行修改的所有并发事务是彼此隔离的）、**持久性**（对数据库的修改被永久保持）

- - 原子性例子：转账操作中的扣款和存款要么同时成功，要么同时失败。
  - 一致性例子：一致性特性保证了在订单提交后，数据库中的订单和库存数量是一致的，不会出现订单提交了但库存没有减少的情况。
  - 隔离性例子：隔离性特性保证了每个用户看到的数据都是一致的，不会出现读取到其他事务未提交的数据或者修改其他事务已经修改的数据的情况。
  - 持久性例子：在数据库中进行数据更新或插入操作后，持久性特性确保数据的变更会被持久地保存到磁盘中。

- **事务的并发**引起了哪些问题？事务并发会引起**脏写、脏读、丢失更新、不可重复读、幻读**问题。
- **脏读**：一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中时有另一个事务也访问了这个修改的数据然后使用这个数据。由于这个数据还没有提交到数据库，因此另一个事务读到的数据是脏数据，会导致数据的一致性（数据可能回滚）。
- **脏写**：一个事务对数据进行了修改，但在事务提交之前，另一个事务读取了该未提交的数据，并使用了这个尚未持久化的值，会导致数据不一致和丢失更新的问题。
- **丢失更新**：当两个或多个事务并发读取并更新同一数据时，如果其中一个事务的更新结果被另一个事务的更新覆盖导致部分事务的更新丢失，称为丢失更新。
- **不可重复读**：一个事务中多次读取同一行数据时，如果其他事务对该数据进行了修改，导致每次读取的数据不一致，称为不可重复读，导致数据的一致性问题。
- **幻读**：与不可重复读类似，一个事务中执行多次相同的查询语句时，如果其他事务对查询结果中的行进行了插入、删除、修改，导致每次查询结果不一样，称为幻读
- **MySQL** 的事务隔离级别一共有四个，分别是**读未提交、读已提交、可重复读以及可串行化**。
- **可重复读**：事务在读取数据时会创建一个快照，其他事务对数据的修改不会被读取到，避免不可重复读问题。可串行化：事务串行执行确保事务之间没有冲突。

| **隔离事务** | **脏读** | **不可重复读** | **幻读** |
| ------------ | -------- | -------------- | -------- |
| 读未提交     | ✔        | ✔              | ✔        |
| 读已提交     | ✖️        | ✔              | ✔        |
| 可重复读     | ✖️        | ✖️              | ✔        |
| 可串行化     | ✖️        | ✖️              | ✖️        |

- 优化表：限定数据查找范围、读写分离、垂直分区、水平分区
- **MVCC**原理不太懂，但是我知道的是并发访问的时候，通过对数据进行多版本管理，避免因为写数据时无法读数据的问题，保留数据历史版本，大概流程时事务开启获得事务版本号，获得一个readview，查询数据，与Readview事务版本号进行匹配，不符合readview规则从undo log获取历史版本数据，返回符合规则的数据
- 直接修改表结构的过程中会锁表，修改字段长度可能会锁表
- delete和truncate只删除表数据，不删除表结构。速度drop > truncate > delete。delete是dml(data manipulation language操作语句)事务提交后才生效, truncate,drop是ddl(data definition)，操作立即生效。
- left outer join全部左∩右，full outer join全部关联，inner join左∩右
- 数据库并发策略：乐观锁：版本号控制和CAS操作，回滚事务、悲观锁：行级锁与表级锁，并发冲突较多且数据修改频繁
- MySQL 5种类型表格：MyISAM、Heap、Merge、InnoDB引擎(B+树)、ISAM
- **InnoDB和ISAM**区别：InnoDB支持事务，ISAM不支持事务处理和并发操作。InnoDB支持外键。InnoDB是聚族索引，MyISAM是非聚族索引。InnoDB支持最小锁粒度是行锁，MyISAM是表锁。
- Char是固定长度字符串类型(剩余用空格填充)，Varchar是动态变化长度字符串类型
- 锁的优化策略：读写分离、分段加锁、减少锁持有时间
- 优化MySQL：SQL语句及索引优化、数据库表结构优化、系统配置优化、硬件优化
- 优化数据库：选取适用的字段属性、使用JOIN和UNION、事务处理、锁定表、使用外键、建立索引、优化查询语句
- 合适数据类型int > date,time > enum,char > varchar > blob,text
- 乐观锁：用户读数据时，别人不会去写自己所读的数据
- 悲观锁：在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加锁，只有自己把数据读完了，才允许别人修改那部分数据
- 时间戳：不加锁，通过时间戳来控制并发出现的问题
- 行级锁：一种排他锁，防止其他事务修改此行，速度慢，资源消耗多，冲突少
- 表级锁：对当前操作的整张表加锁，速度快，资源消耗少，冲突多，有共享锁和排他锁（写锁）
- 页级锁：介于行级锁与表级锁，一次锁定相邻的一组记录。
- MySQL行锁是否会出现死锁，会，比如在并发情况，事务A获取行1的锁并请求行2的锁，同时事务B获取行2的锁并请求获取行1的锁，进入了死锁。MySQL会自动检测死锁并牺牲其中一个事务进行回滚，解除死锁。

## 数据类型

| 类型              | 存储大小                       |
| ----------------- | ------------------------------ |
| **TINYINT**       | 1 字节 (8 位)                  |
| **SMALLINT**      | 2 字节 (16 位)                 |
| **MEDIUMINT**     | 3 字节 (24 位)                 |
| **INT / INTEGER** | 4 字节 (32 位)                 |
| **BIGINT**        | 8 字节 (64 位)                 |
| **BIT(M)**        | `约 (M+7)/8` 字节，M 范围 1~64 |

## 🔹 定点/浮点

| 类型              | 存储大小                                                  |
| ----------------- | --------------------------------------------------------- |
| **DECIMAL(M,D)**  | 取决于精度，约 `M/9*4` 字节（MySQL 内部以字符串压缩存储） |
| **FLOAT**         | 4 字节                                                    |
| **DOUBLE / REAL** | 8 字节                                                    |

## 🔹 日期与时间

| 类型          | 存储大小                                                 |
| ------------- | -------------------------------------------------------- |
| **DATE**      | 3 字节                                                   |
| **DATETIME**  | 8 字节（MySQL 5.6 之前为 8，5.6+ 为 5~8 取决于小数精度） |
| **TIMESTAMP** | 4 字节（5.6+ 为 4~7，取决于小数精度）                    |
| **TIME**      | 3 字节（5.6+ 为 3~6，取决于小数精度）                    |
| **YEAR**      | 1 字节                                                   |

## 🔹 字符串

| 类型                                  | 存储大小                                                     |
| ------------------------------------- | ------------------------------------------------------------ |
| **CHAR(M)**                           | 定长 M 字节（字符集不同影响实际占用，比如 utf8mb4 一个字符最多 4 字节） |
| **VARCHAR(M)**                        | 实际字符字节数 + 1~2 字节长度标识                            |
| **TEXT/TINYTEXT/MEDIUMTEXT/LONGTEXT** | 分别为最大 2^8、2^16、2^24、2^32 - 1 字节，外加 1~4 字节长度标识 |
| **BLOB/TINYBLOB/MEDIUMBLOB/LONGBLOB** | 与 TEXT 类似，只是存储二进制                                 |

## 🔹 其他

| 类型     | 存储大小                                                     |
| -------- | ------------------------------------------------------------ |
| **ENUM** | 1 或 2 字节（取决于枚举成员个数，< 255 用 1 字节，否则 2 字节） |
| **SET**  | 1, 2, 3, 4, 或 8 字节（取决于 SET 成员个数）                 |

## 单表数据量建议

数据库单表**建议最大2kw**条数

假设

- 非叶子结点内指向其他内存页的指针数量为`x`
- 叶子节点内能容纳的record数量为`y`
- B+树的层数为`z`

![img](https://cdn.nlark.com/yuque/0/2025/png/29188914/1758968614288-aa7c92ce-0f1c-42c7-a7d8-d7fd65c032f9.png)

图片

总行数的计算方法

那这棵B+树放的**行数据总量**等于 `(x ^ (z-1)) * y`。

### x怎么算

我们回去看数据页的结构。

![img](https://cdn.nlark.com/yuque/0/2025/png/29188914/1758968614957-6cf53aeb-505d-4d91-86e4-5bb483d8a49d.png)

图片

页结构

非叶子节点里主要放索引查询相关的数据，放的是主键和指向页号。

主键假设是`bigint（8Byte）`，而页号在源码里叫`FIL_PAGE_OFFSET（4Byte）`，那么非叶子节点里的一条数据是`12Byte`左右。

整个数据页`16k`， 页头页尾那部分数据全加起来大概`128Byte`，加上页目录毛估占`1k`吧。那剩下的**15k**除以`12Byte`，等于`1280`，也就是可以指向**x=1280页**。

我们常说的[二叉树](https://zhida.zhihu.com/search?content_id=197800140&content_type=Article&match_order=1&q=二叉树&zhida_source=entity)指的是一个结点可以发散出两个新的结点。[m叉树](https://zhida.zhihu.com/search?content_id=197800140&content_type=Article&match_order=1&q=m叉树&zhida_source=entity)一个节点能指向m个新的结点。这个指向新节点的操作就叫**扇出（fanout）**。

而上面的B+树，它能指向1280个新的节点，恐怖如斯，可以说**扇出非常高**了。

### y的计算

叶子节点和非叶子节点的[数据结构](https://zhida.zhihu.com/search?content_id=197800140&content_type=Article&match_order=1&q=数据结构&zhida_source=entity)是一样的，所以也假设剩下`15kb`可以发挥。

叶子节点里放的是真正的行数据。假设一条行数据`1kb`，所以一页里能放**y=15行**。

### 行总数计算

回到 `(x ^ (z-1)) * y` 这个公式。

已知`x=1280`，`y=15`。

假设B+树是**两层**，那`z=2`。则是`(1280 ^ (2-1)) * 15 ≈ 2w`

假设B+树是**三层**，那`z=3`。则是`(1280 ^ (3-1)) * 15 ≈ 2.5kw`

**这个2.5kw，就是我们常说的单表建议最大行数2kw的由来。**毕竟再加一层，数据就大得有点离谱了。三层数据页对应最多三次磁盘IO，也比较合理。

### 行数超一亿就慢了吗？

上面假设单行数据用了1kb，所以一个数据页能放个15行数据。

如果我单行数据用不了这么多，比如只用了`250byte`。那么单个数据页能放60行数据。

那同样是三层B+树，单表支持的行数就是 `(1280 ^ (3-1)) * 60 ≈ 1个亿`。

你看我一个亿的数据，其实也就三层B+树，在这个B+树里要查到某行数据，最多也是三次磁盘IO。所以并不慢。

这就很好的解释了文章开头，为什么我单表1个亿，但查询性能没啥大毛病。

## 索引

- **SQL索引**失效的几种情况

1、使用 != 或者 <> 导致索引失效

2、类型不一致导致索引失效

3、函数导致索引失效

4、运算符导致索引失效

5、模糊搜索导致索引失效，Like

6、OR引起的索引失效，如果OR连接的是同一个字段则不会失效（没有同时使用索引），反之失效

7、NOT IN、NOT EXISTS导致索引失效，in 是走索引的8、IS NULL走索引，IS NOT NULL不走索引

- sql select语句先后，from(join/on),where,group by,聚集函数计算(sum),having,计算表达式,select(distinct),orderby排序,top
- 索引可以提高检索速度，索引的实现使用B树或B+树，缺点：维护索引耗时（对数据进行修改/增加/删除），降低效率，需要占用物理空间
- Hash索引底层基于哈希表实现，使用Hashcode，由于没有顺序，IO复杂度高
- 查看MySQL语句有没有用到索引，使用explain关键字
- 为什么使用自增长主键作为索引，因为自增长是连续的，每次插入数据都是插入到最后
- 创建索引方式，create table, alter table add index, create index on table (column)
- 创建索引时应指定列为NOT NULL，取值离散大的字段，索引字段越小越好，频繁使用的数据适合建立索引，索引没有重复值，可以有一个空值。
- 创建索引原则，最左前缀匹配原则，mySQL会一直向右匹配直到遇到范围查询(x>3之类)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整，=和in可以乱序。尽量选择区分度高的列作为索引。索引列不能参与计算，保持列干净
- 通过索引查询数据比全表扫描要快，但是索引需要空间存储和定期维护，有记录被修改时，索引本身也会修改，所以会多付出4/5次的磁盘I/O。索引查询不要使用where对null值判断。
- 索引主要有主键索引、唯一索引、聚族索引、覆盖索引、组合索引。主索引B+树是主键在非叶子节点，然后通过主键去查找，找到对应的叶子节点，其余都是主键、地址、指针。
- 聚族索引：主键，B+树，通过主键来进行查询，性能O(logN)
- 非聚族索引：普通索引、唯一索引、全文索引、组合索引、前缀索引，通过该字段索引的B+树去查找，找到后再根据该叶子节点存储的主键id去查找主键B+树。
- 主键通常使用自增id，聚族索引的数据的物理存放顺序与索引顺序是一致的，只要索引是相邻的，对应的数据存放在磁盘上也是相邻的。
- 从二级索引“跳”到主键索引获取全部数据，再拿数据的过程就叫 **回表**。
- ![img](https://cdn.nlark.com/yuque/0/2025/jpeg/29188914/1758934556489-05d4dbef-d9e3-4399-8c53-8ff073e2fe10.jpeg)

Explain字段

| 字段名            | 含义                     | 举例                                                         | 说明                                  |
| ----------------- | ------------------------ | ------------------------------------------------------------ | ------------------------------------- |
| **id**            | 查询序号（执行顺序标识） | 1 / 2 / 3                                                    | 数字越大优先执行（子查询/联合查询中） |
| **select_type**   | 查询类型                 | SIMPLE / PRIMARY / SUBQUERY / UNION                          | 说明是否是子查询、联合查询等          |
| **table**         | 当前执行的表名           | `user`                                                       | 说明正在访问哪张表                    |
| **partitions**    | 使用的分区               | NULL                                                         | 用于分区表                            |
| **type**          | 访问类型（非常重要）     | `ALL`, `index`, `range`, `ref`, `eq_ref`, `const`, `system`  | 表示扫描方式，越往右效率越高          |
| **possible_keys** | 可能使用的索引           | `idx_user_id`                                                | 表示优化器考虑过的索引                |
| **key**           | 实际使用的索引           | `idx_user_id`                                                | 最终选中的索引（NULL 表示未使用索引） |
| **key_len**       | 索引长度                 | `4`                                                          | 索引中使用的字节数（越短越好）        |
| **ref**           | 与索引比较的列或常量     | `const` / `u.id`                                             | 表示索引匹配的方式                    |
| **rows**          | 预估扫描的行数           | `1000`                                                       | 预估要读取多少行（越少越好）          |
| **filtered**      | 过滤比例（0~100）        | `10.0`                                                       | 表示通过条件过滤后剩下的百分比        |
| **Extra**         | 额外信息                 | `Using where`, `Using index`, `Using filesort`, `Using temporary` | 各种提示信息，性能关键点              |

type类型

| type               | 含义                               | 性能     |
| ------------------ | ---------------------------------- | -------- |
| **ALL**            | 全表扫描                           | ❌ 最差   |
| **index**          | 全索引扫描                         | ❌        |
| **range**          | 范围扫描（如 `BETWEEN`, `>`, `<`） | ✅ 一般   |
| **ref**            | 普通索引等值匹配                   | ✅ 好     |
| **eq_ref**         | 唯一索引等值匹配（如主键）         | ✅✅       |
| **const / system** | 常量匹配（1行）                    | ✅✅✅ 最快 |

### B树和B+树的区别：

1. 1. B树的每个节点都存储了key和data，而B+树的data存储在叶子节点上。**B+树非叶子节点仅存储key不存储data，这样一个节点就可以存储更多的key，可以使得B+树相对B树来说更矮（IO次数就是树的高度），所以与磁盘交换的IO操作次数更少。**
   2. B+树所有叶子节点构成一个 *有序链表*，按主键排序来遍历全部记录，能更好支持**范围查找**。由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历，相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。
   3. B+树所有的查询都要从根节点查找到叶子节点，**查询性更稳定**；而B树，每个节点都可能查找到数据，需要在叶子节点和内部节点不停的往返移动，所以不稳定。

### 深度翻页

- 假设用 SQL：

```sql
SELECT * FROM user ORDER BY id LIMIT 10 OFFSET 1000000;
```

表示要查 **第 100001 页** 的数据（每页 10 条）。

👉 这就叫 **深度翻页**（deep pagination）。

问题：数据库在执行时

- 从头扫描出 **1,000,010 条数据**；
- 丢掉前 1,000,000 条；
- 只返回最后 10 条。

导致：

- **性能极差**（浪费 I/O 和 CPU）；
- **延迟高**；
- **随着页数变大，响应时间线性上升**。

**常见优化方法：**

1. **基于游标分页（Keyset Pagination / Seek Pagination）**

```plsql
SELECT * FROM user
WHERE id > #{lastId}
ORDER BY id
LIMIT 10;
```

- - 通过上次返回的最后一条记录的 id 来定位下一页；
  - 性能稳定，不管翻到多深；
  - 适合时间线、日志、交易流水等顺序场景。

1. **基于时间或主键范围分页**

```plsql
SELECT * FROM order
WHERE created_at BETWEEN '2025-10-01' AND '2025-10-02'
ORDER BY created_at;
```

# 计算机网络

- 200：成功，Web 服务器成功处理了客户端的请求。
- 301：永久重定向，当客户端请求一个网址的时候，Web 服务器会将当前请求重定向到另一个网址，搜索引擎会抓取重定向后网页的内容并且将旧的网址替换为重定向后的网址。
- 302：临时重定向，搜索引擎会抓取重定向后网页的内容而保留旧的网址，因为搜索引擎认为重定向后的网址是暂时的。
- 400：客户端请求错误，多为参数不合法导致 Web 服务器验参失败。
- 404：未找到，Web 服务器找不到资源。
- 500：Web 服务器错误，服务器处理客户端请求的时候发生错误。
- 503：服务不可用，服务器停机。
- 504：网关超时。
- Forward是服务器内部重定向，Redirect是客户端重定向
- GET请求从服务器获取资源，POST请求向服务器提交数据
- **TCP**面向连接，可靠的数据传输，需要建立连接导致延迟，有序，传输速度慢，连接只能是点到点的(一对一)，对系统资源要求多，TCP基于字节流传输。
- TCP/IP，TCP是保证安全传输数据的协议，IP协议是来连接网络，TCP/IP结构有应用层、传输层、网络层、数据链路层、物理层（TCP/IP没有）
- **UDP**无连接协议，不保证可靠传输，有较好的实时性，无序，适用于高速传输，支持一对一、一对多、多对一、多对多的通信交互，对系统资源要求少，UDP基于数据包传输
- **OSI七层模式**：

- - 应用层：负责处理用户与网络应用之间的交互，例如HTTP、SMTP、FTP等协议，实现Web浏览、电子邮件、文件传输等。
  - 表示层：主要负责处理数据的格式、编码、和加密解密，将应用层传递过来的数据进行格式转换、数据压缩、数据加密等。
  - 会话层：负责建立、管理和终止会话连接。
  - 传输层：负责提高端到端的可靠数据传输，使用TCP或UDP协议，将数据分割成较小数据包，确保它们按序传输。还处理数据包的重传、流量控制和拥塞控制等。
  - 网络层：负责网络互联和数据包的路由，使用IP协议将数据包从源主机传输到目标主机，通过路由选择算法缺点最佳路径，并处理数据包分片和重新组装。
  - 数据链路层：主要负责将数据转换为适合在物理介质上传输的格式，将网络层传递过滤的数据包封装成帧，添加源和目标MAC地址，并进行数据的差错检测和纠正。
  - 物理层：通过物理介质，电缆、光纤进行传输，并处理信号的编码。

- Http1.0无状态，无连接、Http1.1持久连接(Keep-alive)，请求，增加缓存处理，增加Host字段、Http2.0二进制分帧，多路复用(并行传输)，头部压缩(encoder)，服务器推送
- **HTTPS**是支持加密和验证的HTTP。两种协议的唯一区别是HTTPS使用TLS (SSL Secure Socket Layer)来加密普通的HTTP 请求和响应(对称加密AES/公私钥不对称加密)，并对这些请求和响应进行数字签名。因此，HTTPS 比HTTP 安全得多。http端口80，https端口443。TLS与SSL是在传输层对网络连接进行加密。
- Socket是TCP/IP网络的API接口
- **TCP三次握手**，由客户端发送syn包序列号seq=x给服务器，服务器接收并发送ack包ack=x+1,seq=y回客户端，客户端确认再发送Ack包ack=y+1给服务器，建立连接成功。
- **断开链接四次挥手**，客户端发送FIN包给服务端进入FIN_WAIT状态，服务器接收后并返回ACK包给客户端进入CLOSE_WAIT状态，服务器发送FIN包表示希望关闭连接进入LAST_ACK状态等待客户端确认，客户端接收后确认关闭发送ACK包进入TIME_WAIT状态等待一段时间进入CLOSED，服务器得到确认也CLOSED
- TCP连接(C++)：

- - 服务端 socket() - bind() - listen() - accept() (若有connect) - read/recv/write/send - close()
  - 客户端 socket() - connect() - read()/recv/write()/send() - close()

- 造成粘包和拆包主要是缓冲区空间不足以发送完整的包、发送的数据超过了最大报文长度限制、要发生的数据包小于TCP缓冲区空间，TCP将多个数据包写满发送将发送粘包、接收端没有及时读取数据包，发送粘包
- 粘包拆包解决方案：给数据包添加首部(Header)并在首部添加数据包的长度属性、发送的数据包小于缓冲区则可规定为同样长度为其补充、给不同的数据包添加间隔符合确定边界。
- 序列号和确认号机制、超时重发机制(发送时启动定时器)、对乱序数据包重新排序、丢弃重复的数据包、流量控制(可变大小的滑动窗口协议sliding window)
- IPv4 32bit，IPv6 128bit
- 浏览器输入URL后，解析URL格式、协议、主机名、路径等，然后DNS解析，发送主机名给DNS服务器获取IP地址，开始建立TCPIP连接(三次握手)，完成连接后发起请求GET/POST，服务器接收请求后并处理请求生成相应数据，然后进行数据传输返回浏览器，浏览器对数据进行解析和渲染，将页面内容显示给用户。
- **DNS解析**是将域名解析为IP地址的过程。浏览器首先检查自己的缓存，看是否已经保存该域名的IP，如果没有回想本地系统的DNS解析器发送DNS请求，向根域名服务器发送请求，根域名服务器接收请求后，返回顶级域名服务器的IP地址。本地系统的DNS解析器收到顶级域名服务器IP地址后，会向顶级域名服务器发送请求，顶级域名服务器接收请求后，会返回该域名对应的域名服务器IP地址。本地系统的DNS解析器收到域名服务器IP地址后，会向该域名服务器发送请求，域名服务器收到请求后会返回域名对应的IP地址。本地系统的DNS解析器接收到IP地址后，返回浏览器，将IP保持到缓存中，以备下次使用。
- **MAC地址**（英语：Media Access Control Address），直译为媒体存取控制位址，也称为**局域网地址（LAN Address），MAC位址，以太网地址（Ethernet Address）或物理地址（Physical Address）**，它是一个用来确认网络设备位置的位址。
- **ARP**(Address Resolution Protocol)是一种用于在局域网中将IP地址解析为MAC地址的协议。它用于解决在数据链路层中，通过目标IP地址找到对应的物理MAC地址的问题。当主机发送数据时，如果目标IP地址在同一局域网中，会通过ARP协议查询目标IP地址对应的MAC地址。过程：发送主机检查自己的ARP缓存，如果目标IP地址的MAC地址存在于缓存中，就直接使用该MAC地址进行数据包封装，如果没有则发送主机会向局域网中的广播地址发送一个ARP请求广播包，请求目标IP地址的MAC地址，局域网中的其他主机接收到ARP请求广播包后，检查自己的IP地址是否匹配，匹配则将自己的MAC地址返回。主机接收到后，将目标IP和MAC地址添加到自己的ARP缓存中。
- 找不到对应的MAC地址，将数据包发送到默认网关（默认路由器）的MAC地址。默认网关接收到数据包后，会先进行路由判断，确定下一跳路由器的MAC地址。然后，将数据包封装在新的数据帧中，目标MAC地址为下一跳路由器的MAC地址，继续向目标IP地址转发。每个路由器都会执行类似的操作，根据路由表确定下一跳路由器，并将数据包转发到下一跳。最终，数据包通过一系列的路由器转发到目标主机所在的局域网。
- **反向代理**：具体来说，当客户端发送请求时，反向代理服务器会接收这些请求，并根据配置的规则将请求转发到内部的目标服务器上。客户端对目标服务器的请求实际上是发送给反向代理服务器，而不是直接发送给目标服务器。客户端和服务器的中间层。实现负载均衡、缓存和加速、安全性和保护(SSL加密)、高可用性。

# 操作系统

- 进程状态：创建、就绪、运行、阻塞、终止
- 线程状态：创建、就绪、运行、阻塞、等待、超时等待、终止
- 进程和线程区别：一个进程中可以包含多个线程，每条线程执行不同的任务；不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间；每个线程拥有单独的栈内存用来存储本地数据。
- 并发是在一段时间内交替执行，多个任务被处理，但在某一时刻只有一个任务执行
- 并行就是在同一时刻，有多个任务在执行，需要多核处理器执行不同程序
- 进程切换：分两步，切换页表以使用新的地址空间，一旦切换上下文，处理器所有已经缓存的内存地址作废。切换内核栈和硬件上下文。
- 线程切换：切换内核栈和硬件上下文
- 由于每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间，因此线程切换不涉及虚拟地址空间。
- 虚拟地址切换比较耗时，虚拟地址切换到物理地址需要查找页表，页表查找是一个很慢的过程，因此通常使用Cache来缓存常用的地址映射，加速页表查找。进程切换后页表也需要切换，页表切换后TLB也就失效了，Cache失效就导致命中率低，那么虚拟地址转换物理地址就会变慢。
- **进程通信方式**：管道(有名管道和无名管道)、信号、信号量、消息队列、共享内存、socket。
- **无名管道**：半双工通信，数据只能单向流动，只能在具有亲缘关系的进程间使用(父子进程关系)，简单方便但是局限于单向通信和亲缘关系。**有名管道**：半双工的通信，以磁盘文件的方式存在，可以实现任意两个进程的通信，允许无亲缘关系进程间的通信，但是缓冲区有限。
- **信号**：一种比较复杂的通信方式，用于通知接收进程某个事件
- **信号量**：一个计数器，用来控制多个线程对共享资源的访问(锁)，可实现同步但是信号量有限。
- **消息队列**：消息的链表，存放在内核中并由消息队列标识符标识，可以实现任意进程间的通信，可通过系统调用函数实现消息发送和接收之间的同步，无需考虑同步问题，但是信息复制需要额外消耗CPU时间，不适合信息量大或操作频繁的场景。
- **共享内存**：映射一段能被其他进程所访问的内存，这段共享内存是由一个进程创建，但多个进程可访问，无需复制，但是可能会出现读写操作的同步问题且不方便网络通信(内存实体只能由计算机系统的多个进程共享)
- **Socket**：可用于不同机器间的进程通信，传输数据为字节级，传输数据时间短，适合客户端和服务端之间信息交互，可以加密保证数据安全性。但是需要对数据进行解析，转换成应用的数据。
- **进程间同步的方法**：**临界区**（某一个时刻只有一个线程能访问数据），**互斥锁**（可跨进程使用），**信号量**（允许多个线程同一时刻访问同一资源，但是得限制访问的最大线程数，适用于Socket程序中的线程同步），**事件**（通知线程的事件已发生，从而启动后续任务开始）
- **线程同步方式**：**临界区**（只有一个线程能访问）、**事件**（完成后幻想另一个线程）、**互斥量**（与临界区相似，只允许进程间使用）、**信号量**（限制线程数量）
- 进程之间私有资源：地址空间、堆、栈、寄存器、全局变量，共享资源：代码段、公共数据、进程目录、进程ID
- 线程之间私有资源：线程栈、寄存器、程序计数器，共享资源：堆、地址空间、、全局变量、静态变量
- 解决临界区冲突方法：若临界区有进程进入了，其他进程必须等待、进入临界区的进程需要在有限时间内退出、如果进程不能进入自己的临界区则应让出CPU
- 死锁：在两个或多个并发进程中，如果每个进程都持有某种资源而又等待其他进程释放它，在未改变这种状态之前都不能推进则这一组进程产生了死锁。产生死锁4个必要条件：互斥、请求与保持、不剥夺、循环等待
- 处理死锁：死锁预防（确保死锁的4个必要条件至少1个不成立）、死锁避免（银行家算法，进程请求量，进程最大需求量，系统中该资源总量）、死锁检测、死锁解除（终止进程和资源抢占，回滚）、鸵鸟策略（忽略死锁因为发生概率低）
- 进程调度策略：FCFS(有利于长作业但不利于短作业)、SJF(利于短作业但是长作业可能会饥饿)、SRTF(最短剩余时间优先)、RR(时间片轮转，按FCFS排成一个队列，每个进程执行一个时间片)、Priority Scheduling(优先级调度)
- 分页：把内存空间划分为大小相等且固定的块，需要页表来记录映射关系，实现从页号到物理块号的映射。（为了提高内存利用率）
- 分段：为了满足程序员在编写代码时的一些逻辑需求（数据共享、数据保护、动态链接等）
- 分页是透明的，分段需要程序员划分每个段、分页地址空间为一维，分段是二维、页的大小不可变，段的大小可动态改变、分页主要用于实现虚拟内存获得更大的地址空间，分段主要是为了程序员和数据可以被划分为逻辑上独立的地址空间并有助于共享和保护。
- 交换空间，把页的内容转移到硬盘的一块空间上，释放内存空间。
- 缓存淘汰算法(页面替换)，FIFO、LRU(最近最少)、LFU(频率最低)
- 缓冲区溢出：指计算机向缓冲区输入数据时超过了缓冲区的容量，溢出的数据覆盖其他合法的数据，造成程序崩溃或被攻击者执行恶意代码。需要对输入进行验证和检查并控制缓冲区大小。
- 虚拟内存是为了可以加载更多的进程资源到内存。虚拟内存的实现方式：请求分页管理、请求分段管理、请求段页式管理。
- IO多路复用：内核发现进程指定一个或多个IO条件准备读取，它就通知进程。适用场合有：TCP服务器处理监听接口又要处理已连接接口、一个服务器要处理多个服务或协议。IO多路复用的优势在于可以通过一个线程同时处理多个IO操作(select, epoll, poll)
- 硬链接就是在目录下创建一个条目，记录着文件名与inode编号，这个inode是源文件的inode，删除任意一个条目，文件还是存在的，不能跨文件系统。符号链接(软链接)保持着源文件所在绝对路径，在读取时会定位到源文件（快捷方式），源文件被删除后，链接文件就打不开了。
- 中断处理过程：将当前执行程序的数据保存在寄存器中，然后入栈、开中断，以便执行中断时能响应较高级别的中断请求、中断处理、关中断，保证恢复现场时不被新中断干扰、恢复现场，从堆栈中按序取出程序数据，恢复中断前的执行状态。
- 内核态运行的程序可以访问计算机任何数据和资源，不受限制。用户态运行的程序只能受限地访问内存，只能直接读取用户程序的数据，并不允许访问外围设备。
- 用户态转换内核态使用trap指令
- 一次IO访问(read举例)，数据会先被拷贝到操作系统内核的缓冲区，然后才从操作系统缓冲区拷贝到程序的地址空间。
- select时间复杂度O(n)，仅仅知道有I/O事件，只能无差别轮询所有流
- poll时间复杂度O(n)，与select没有区别，将数组拷贝到内核空间，没有最大连接数的限制，因为是基于链表
- epoll时间复杂度O(1)，event poll会将哪个流发生了怎样的I/O事件通知我们，实际上是事件驱动

# 数据结构

- 二叉树，满二叉树，完全二叉树（除了最后一级不全满叶），完美二叉树（完整的二叉树，2^i-1)
- 红黑树，一种自平衡的二叉查找树，根节点是黑色，所有叶子(NIL)都是黑色，每个红节点的两个子节点都是黑色，从任何一节点到其每个叶子的所有路径都包含相同数目的黑色节点。左旋、右旋、变色
- B+树，比如2-3树，当前节点2个值，有三个子节点，用于索引，分为两种节点：内部节点(存储数据和指向子节点的指针)，叶子节点(只存数据，没有子节点)，磁盘读写代价低。
- B树是一种自平衡树，每个节点可以存储多个关键字和对应的值，且每个节点可以拥有多个子节点。时间复杂度保持在O(logN)。B+树是B树基础上进行优化，B+树的内部节点不存储数据，只存储关键字和子节点指针，所有的数据都存储于叶子节点。叶子节点之间通过指针进行连接，形成有序链表，方便查询。叶子节点之间没有相邻关系，可以独立存储更多关键字和数据。B+树相对于B树的优点，减少磁盘I/O次数，由于B+树数据只存储在叶子节点，相比之下B树需要在非叶子节点和叶子节点进行多次磁盘操作。提高范围查询性能，B+树的叶子节点形成有序链表。B+树的查询都要从根节点查找到叶节点，查询性能更好。B+树的特性更适合存储大量数据的场景，如数据库和文件系统。
- AVL树，自平衡二叉查找树，任何节点的两个子树的高度最大差别为1，左-右，旋转L(-1,-2), R(1,2), LR(-1,2), RL(1,-2)
- 排序算法 归并排序merge sort分成前后然后递归nlogn时间复杂，快排选基准值pivot，一般取最后一个，小于放到左边，大于放到右边 nlogn时间复杂
- 二分查找，计算中间位置，比较中间元素，更新查找范围，前提是数组必须是有序的，时间复杂度logn
- Preorder: 中 - 左 - 右, Inorder: 左 - 中 - 右, Postorder: 左 - 右 - 中

```plain
public class anytesting {
    public static void bubbleSort(int[] arr){
        int n = arr.length;
        for(int i = 0 ; i < n; i++){
            for(int j = 0 ; j < n - i - 1 ; j++){
                if(arr[j] > arr[j+1]){
                    int temp = arr[j+1];
                    arr[j+1] = arr[j];
                    arr[j] = temp;
                }
            }
        }
    }

    public static void quickSort(int[] arr, int low, int high){
        if(low < high){
            int pivot = partition(arr, low, high);
            quickSort(arr, low, pivot-1);
            quickSort(arr, pivot+1, high);
        }
    }

    public static int partition(int[] arr, int low, int high){
        int pivot = arr[high];
        int i = low-1;
        for(int j = low ; j < high ; j++){
            if(arr[j] < pivot){
                i++;
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
        int temp = arr[i+1];
        arr[i+1] = arr[high];
        arr[high] = temp;
        return i+1;
    }

    public static void mergeSort(int[] arr, int left, int right){
        if(left < right){
            int mid = (left + right) / 2;
            mergeSort(arr, left, mid);
            mergeSort(arr, mid+1, right);
            merge(arr, left, mid, right);
        }

    }

    public static void merge(int[] arr, int left, int mid, int right){
        int n1 = mid - left + 1;
        int n2 = right - mid;
        int[] L = new int[n1];
        int[] R = new int[n2];
        for(int i = 0 ; i < n1 ; i++){
            L[i] = arr[left+i];
        }
        for(int i = 0 ; i < n2 ; i++){
            R[i] = arr[mid+i+1];
        }
        int i = 0, j = 0;
        int k = left;
        while(i < n1 && j < n2){
            if(L[i] <= R[j]){
                arr[k] = L[i];
                i++;
            }else{
                arr[k] = R[j];
                j++;
            }
            k++;
        }
        while(i < n1){
            arr[k] = L[i];
            i++;
            k++;
        }
        while(j < n2){
            arr[k] = R[j];
            j++;
            k++;
        }
    }

    public static void main(String[] args) {
        int[] arr = {50, 40, 60, 30, 90, 10, 20, 70, 80};
        int n = arr.length;
        bubbleSort(arr);
        System.out.print("bubblesort: [");
        for (int num : arr){
            if(num != arr[n-1])
                System.out.print(num + ", ");
            else System.out.print(num);
        }
        System.out.println("]");
        int[] arr1 = {50, 40, 60, 30, 90, 10, 20, 70, 80};
        int n1 = arr1.length;
        quickSort(arr1, 0, n1-1);
        System.out.print("quicksort: [");
        for (int num : arr1){
            if(num != arr1[n1-1])
                System.out.print(num + ", ");
            else System.out.print(num);
        }
        System.out.println("]");
        int[] arr2 = {50, 40, 60, 30, 90, 10, 20, 70, 80};
        int n2 = arr2.length;
        quickSort(arr2, 0, n2-1);
        System.out.print("mergesort: [");
        for (int num : arr2){
            if(num != arr2[n2-1])
                System.out.print(num + ", ");
            else System.out.print(num);
        }
        System.out.println("]");
    }
}
```

# Linux命令

- linux指令 cat filename显示文件内容，cat > filename创建文件(touch filename)，cat file1 file2 > file3合并创建新文件，cat -n file1 > file2第一个追加到第二个，cat : >file2清空文件
- 查看日志 tail -n 10 test.log, tail -n +10除了前10行, tail -fn 10循环查看最后1000行, tail -n 4700 aa.log |more -1000 可以进行多屏显示(ctrl + f 或者 空格键可以快捷键）
- head同样head -n 10前十行, head -n -10除了后10行
- 打包：tar -xvf，打包并压缩：tar -zcvf
- more filename，按页查看文件内容, space向下翻页, enter向下滚动, 与less相似
- sed指令可以查找日志的特定一段，sed -n '5, 10p' filename
- history所有历史记录, history | grep xxx, history | more, history -c 清空
- 软链接ln -s destlink source, 硬链接ln destlink source
- chmod, 4-read, 2-write, 1-execute, owner-group-everyone
- echo "Hello World"打印字符串
- 复制文件cp source destination
- wc filename，统计文件行数(-l)、字数(-w)、字节数(-c)、字符(-m)
- grep -i "Hello" file忽略大小写进行搜索, 不含该字符串的行 grep -iv "hello" file
- 使一个命令在后台运行，./script.sh &，加'&'
- jobs查看后台任务，job -l 作业号查看后台任务，切换到前台fg 作业号，bg 作业号挂起或恢复
- ps -ef, -e显示所有进程, -f全格式显示进程信息终止进程kill -9 pid
- whereis `-b`：只搜索可执行文件,`-s`：只搜索源代码文件,`-m`：只搜索帮助文档。
- ifconfig eth0查看接口配置网络, netstat查看网络连接和网络统计信息, -a显示所有连接和监听接口，包括TCP和UDP，-t显示TCP连接和监听接口，-u显示UDP连接和监听接口，-r显示路由信息，-p进程 -n IP/Port
- env $Home查看环境变量，compgen -c查看当前系统支持的所有命令，repquota查看文件系统的磁盘空间配额

# Java命令排查

## 常用指令

`jps`：显示当前用户的所有java进程的PID

`jps -v 3331`：显示虚拟机参数

`jps -m 3331`：显示传递给main()函数的参数

`jps -l 3331`：显示主类的全路径

`jinfo -flag CMSIniniatingOccupancyFration 3331`：查询CMSIniniatingOccupancyFration参数值

`jstat -gc 3331 250 20` ：查询进程2764的垃圾收集情况，每250毫秒查询一次，一共查询20次。

`jstat -gccause`：额外输出上次GC原因

`jstat -class`：查询类装载、类卸载、总空间以及所消耗的时间

`jmap -heap 3331`：查看java 堆（heap）使用情况

`jmap -histo 3331`：查看堆内存(histogram)中的对象数量及大小

`jmap -histo:live 3331`：JVM会先触发gc，然后再统计信息

`jmap -dump:format=b,file=heapDump 3331`：将内存使用的详细情况输出到文件，之后一般使用其他工具进行分析。

`jhat heapDump`：解析Java堆转储文件,并启动一个 web server

`jstack 3331`：查看线程情况

`jstack -F 3331`：正常输出不被响应时，使用该指令

`jstack -l 3331`：除堆栈外，显示关于锁的附件信息

## 常见问题定位过程

### 频繁GC问题或内存溢出问题

一、使用`jps`查看线程ID

二、使用`jstat -gc 3331 250 20` 查看gc情况，一般比较关注PERM区的情况，查看GC的增长情况。

三、使用`jstat -gccause`：额外输出上次GC原因

四、使用`jmap -dump:format=b,file=heapDump 3331`生成堆转储文件

五、使用jhat或者可视化工具（Eclipse Memory Analyzer 、IBM HeapAnalyzer）分析堆情况。

六、结合代码解决内存溢出或泄露问题。

### 死锁问题

一、使用`jps`查看线程ID

二、使用 jstack pid 查看线程情况

# Redis

- 为什么要使用redis而不是本地缓存？Redis解决本地缓存是使用分布式的方式 ，为什么不用本地缓存，因为如果token只存在一个本地服务，那么如果去访问其他服务则会出现找不到token。Redis有主从、哨兵、集群模式，主从复制、分载均衡（读操作）、预防宕机（哨兵集群互相监控）。Redis Cluster集群模式实现分布式存储，对数据进行分片，任意一个节点都能连通。hash slot算法，固定16384个hash slot，对每个key计算CRC16值，然后对16384取模，可获取key对应hash slot.
- Redis适合读写频繁，量小，有时间限制，存储不唯一，可以丢弃的数据。
- Redis高性能的 key-value 类型内存数据库，可持久化到磁盘，也支持**string, list, set, zset(sortedset), hash，Bitmap**位图，Hyperloglog统计基数的数据集合类型，Geospatial存储地理位置信息。Redis的所有操作是原子性的，要么成功要么失败。
- Redis好处：读写性能高，速度快，因为数据存在内存中，支持丰富数据类型，支持事务(并**不是原子性**，支持隔离性需要配合watch)，命令执行操作都是原子性的，丰富的特性，可用于缓存，消息，按key设置过期时间，过期后自动删除。
- 缺点：数据库容量受物理内存限制，主机宕机的话，会有部分数据未能同步到从机。
- Redis是单进程单线程的(6.0之前)（纯内存操作，效率高），网络IO，利用队列技术将并发访问改为串行访问，避免多线程的切换和锁资源竞争。采用hash结构。
- 一个字符串类型的值能存储最大容量是512M。
- Redis使用多路复用IO技术，将epoll作为I/O多路复用技术的实现。
- **Redis比Memcached的优势**：Memcached所有的值均是简单的字符串，Redis作为替代者，支持丰富的数据类型。Redis速度比Memcached快很多。Redis可以**持久化数据**, memCache存到内存而已。相同点都采用Master线程-Worker线程模型。Redis使用分布式。Redis使用单线程，MemCache使用CAS。超过100K数据就使用MemCache
- 为什么要使用Redis做缓存，从高并发来说，因为直接操作缓存能够承受的请求远远大于直接访问数据库的，所以把部分数据转移到缓存中。从高性能来说，用户第一次访问数据需要从硬盘读取过程比较慢，之后将该数据存在缓存中，下一次再访问就可以直接从缓存获取了。
- redis命令：redis-cli进入redis本地服务、redis-cli -h host -p port -a password。SET key value, GET key, DEL key, DUMP key(序列化), 事务MULTI开始一个事务然后写GET/SET这些，最后EXEC执行，Discard取消事务，watch监视一个或多个key。STRLEN key。
- Redis事务Multi, Exec, Discard, Watch
- 并发量太大导致宕机解决方案：设置允许连接的最大客户端数量、限制并发请求(限流)、增加硬件资源。
- Redis应用场景：缓存、排行榜、计数器、分布式会话session、分布式锁、社交网络(关注、点赞)、最新列表、消息系统
- 多线程(6.0)：BIO线程负责文件关闭、AOF缓冲数据刷新到磁盘、清理回收线程。bgrewriteaof命令，子进程将临时AOF写入数据库。bgsave，子进程将内存所有数据通过快照做一次持久化，写入RDB快照中。
- RDB Redis Database持久化方式：用数据集快照的方式(半持久化模式)记录 redis 数据库的所有键值，但是这是间隔一段时间进行的持久化，如果持久化发生故障会导致数据丢失。
- AOF Append-only file持久化方式： 是指所有的命令行记录以 redis 命令请求协议的格式完全持久化存储)保存为 aof 文件。
- 同步持久化appendfsync always，异步appendfsync everysec每秒同步，appendfsync no不同步
- 缓存使用的话，使用一致性哈希实现动态扩容缩容。持久化存储使用的话，固定的keys-to-nodes映射关系。
- 惰性删除：设置key过期时间，不去管它，当需要该key时，检查是否过期，如果过期则删掉它。
- 定时删除：设置key过期时间同时，创建一个定时器，让定时器在过期时间到来时，执行删除。
- 定期删除：每个一段时间，对一些key进行检查，删除里面过期的key。
- Redis**模式**：

- - 主从模式：主从复制，主机自动将数据同步到从机，可以进行读写分离。分担读写压力。不具备自动容错和恢复功能。宕机后需要手动把从服务器切换为主服务器。
  - Redis Sentinel哨兵模式：哨兵作为独立进程，监控主从服务器的运行状态，当检测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器。多哨兵模式。
  - Redis Cluster集群模式：由于主从服务器都存储相同数据，浪费内存，于是实现分布式存储，就是每台Redis节点存储不同的内容。任何两个节点都是相互连通的，客户端可以与任何一个节点相结合。引入哈希槽hash slot，有16384个，每个key通过CRC16校验后对16384取模。引入主从复制模型，一个主节点对应多个从节点。
  - Twemprox
  - Codis

- Redis的6种内存淘汰策略：volatile-LRU(Least recently use)，allkeys-lru, volatile-ttl(time to live), volatile-random, allkeys-random, no-eviction禁止驱逐数据
- 缓存异常：数据库和缓存数据不一致、缓存雪崩(大量缓存项同时失效，系统崩溃)、缓存击穿(特定缓存项热点key失效，数据源过载)、缓存穿透(不存在于缓存和数据源的缓存项，恶意无效请求)。
- 保证缓存于数据库双写时的数据一致性：有4种方案，先更新数据库后更新缓存、先更新缓存后更新数据库、先删除缓存后更新数据库(请求B发现缓存不在就去读取数据库得到旧值)、先更新数据库后删除缓存(删除缓存可能出现错误)。

- - 方案1：延时双删，先删缓存，再更新数据库，休眠几毫秒，再次删除缓存。
  - 方案2：更新与读取操作进行异步串行化。
  - 方案3：数据库更新，后删除缓存，利用消息队列进行删除。

- **缓存击穿**：热点key失效导致高并发访问数据库。考虑热点key不设置过期时间、考虑降低打在数据库上的请求数量。
- **缓存穿透**：指数据在缓存中不存在，同时在数据库也不存在。**解决**：将无效的key存放进Redis中，找不到就把这个key保持到Redis中、使用布隆过滤器，先查询key是否存在，不存在直接返回，不让访问数据库。
- **缓存雪崩**：同一时间大规模的key失效，导致宕机。**解决**：均匀过期，设置不同的过期时间、分级缓存，第一级缓存失效就访问第二级、热点数据缓存永不过期、互斥锁、限流降级、开启持久化机制，尽快恢复缓存数据。
- **缓存预热**：系统上线提前将相关缓存数据加载到缓存系统中。
- Redis 4.0引入多线程处理异步任务，Redis6.0在网络模型中实现多线程I/O，执行命令依旧单线程，IO线程只负责读写Socket解析命令，不负责命令处理执行。
- Redis基于内存，然后使用IO多路复用，底层是C语言写的

# 如何实现扫码登陆

PC端、手机端、服务端(Server)

1. PC 访问服务端获取二维码唯一标识和状态（已扫码、未扫码、已失效）
2. 手机扫码并把token给到服务端，并在这生成PC的token
3. PC端长轮询二维码状态，如果成功了返回给PC端token
4. 登录成功

# 空间与时间互换

## 空间换时间

```plain
a = 10, b = 5 swap a and b value
temp = a;
a = b;
b = temp;
```

## 时间换空间

```plain
a = 10, b = 5
a = a + b (15)
b = a - b (10)
a = a - b (5)
a = 5, b = 10
a = a + b (15)
b = a - b (5)
a = a - b (10)
```

# 算法

```plain
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
*/

class Solution {
    public Node connect(Node root) {
        if(root == null){
            return null;
        }
        Queue<Node> queue = new LinkedList<Node>();
        queue.add(root);
        while(!queue.isEmpty()){
            int len = queue.size();
            for(int i = 0 ; i < len ; i++){
                Node temp = queue.poll();
                if(temp.left != null){
                    queue.add(temp.left);
                }
                if(temp.right != null){
                    queue.add(temp.right);
                }
                if(i != len-1){
                    temp.next = queue.peek();
                }
            }
        }
        return root;
    }
}
```

## Singleton

```plain
public class Singleton{
    private static Singleton instance;
    private Singleton(){}
    
    public static Singleton getInstance(){
        if(instance == null){
            synchronized (Singleton.class){
                if(instance == null){
                    //double checking
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }

    public void anyMethod(){
        System.out.println("method");
    }
}
```

## BubbleSort

```plain
public class BubbleSort {

    public static void bubbleSort(int[] arr){
        int n = arr.length;
        for(int i = 0 ; i < n-1 ;i++) {
            for(int j = 0 ; j < n-i-1 ; j++) {
                if(arr[j] > arr[j+1]) {
                    int temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                }
            }
        }
    }

    public static void main(String[] args) {
        int[] arr = {64, 34, 39, 10, 68, 33, 11, 90};
        System.out.print("原数组: ");
        for(int num : arr){
            System.out.print(num + " ");
        }
        System.out.println();
        bubbleSort(arr);
        System.out.print("冒泡排序后: ");
        for(int num : arr){
            System.out.print(num + " ");
        }
    }
}
```

## QuickSort

```plain
public class QuickSort {
    public static void quickSort(int[] arr, int low, int high){
        if(low < high) {
            int pivot = partition(arr, low, high);
            quickSort(arr, low, pivot - 1);
            quickSort(arr, pivot + 1, high);
        }
    }

    public static int partition(int[] arr, int low, int high){
        int pivot = arr[high];
        int i = low;
        for(int j = low ; j < high ; j++) {
            if(arr[j] < pivot) {
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
                i++;
            }
        }
        int temp = arr[i];
        arr[i] = arr[high];
        arr[high] = temp;
        return i;
    }

    public static void main(String[] args) {
        int[] arr = {64, 34, 39, 10, 68, 33, 11, 90};
        System.out.print("原数组: ");
        for(int num : arr){
            System.out.print(num + " ");
        }
        System.out.println();
        int n = arr.length;
        quickSort(arr, 0, n-1);
        System.out.print("快排后: ");
        for(int num : arr){
            System.out.print(num + " ");
        }
    }
}
```

## MergeSort

```plain
public class MergeSort {
    public static void mergeSort(int[] arr, int left, int right) {
        if(left < right) {
            int mid = (left + right) / 2;
            mergeSort(arr, left, mid);
            mergeSort(arr, mid+1, right);
            merge(arr, left, mid, right);
        }
    }

    public static void merge(int[] arr, int left, int mid, int right) {
        int n1 = mid - left + 1;
        int n2 = right - mid;
        int[] L = new int[n1];
        int[] R = new int[n2];
        for(int i = 0; i < n1 ; i++) {
            L[i] = arr[left + i];
        }
        for(int i = 0 ; i < n2 ; i++) {
            R[i] = arr[mid + i + 1];
        }
        int i = 0, j = 0;
        int k = left;
        while(i < n1 && j < n2){
            if(L[i] <= R[j]) {
                arr[k] = L[i];
                i++;
            } else {
                arr[k] = R[j];
                j++;
            }
            k++;
        }
        while(i < n1){
            arr[k] = L[i];
            i++;
            k++;
        }
        while(j < n2) {
            arr[k] = R[j];
            j++;
            k++;
        }
    }

    public static void main(String[] args) {
        int[] arr = {64, 34, 39, 10, 68, 33, 11, 90};
        System.out.print("原数组: ");
        for (int num : arr) {
            System.out.print(num + " ");
        }
        System.out.println();
        int n = arr.length;
        mergeSort(arr, 0, n - 1);
        System.out.print("归并排序后: ");
        for (int num : arr) {
            System.out.print(num + " ");
        }
    }
}
```

## Binary Search

```plain
public class BinarySearch {

    public static int binarySearch(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        while(left <= right) {
            int mid = (left+right) / 2;
            if(target == arr[mid]) {
                return mid;
            }
            if(target < arr[mid]) {
                right = mid-1;
            }else {
                left = mid + 1;
            }
        }
        return -1;
    }

    public static int binarySearchRecursive(int[] arr, int target, int left, int right) {
        if (left <= right) {
            int mid = (left + right) / 2;
            if (target == arr[mid]) {
                return mid;
            }
            if (target < arr[mid]) {
                return binarySearchRecursive(arr, target, left, mid - 1);
            } else {
                return binarySearchRecursive(arr, target, mid + 1, right);
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        int[] arr = {10, 11, 33, 34, 39, 64, 68, 90};
        int target = 33;
        int index = binarySearch(arr, target);
        if (index == -1) {
            System.out.println(target + " Not Found");
        } else {
            System.out.println("Target @ " + index);
        }

        int index2 = binarySearchRecursive(arr, target, 0, arr.length - 1);
        if (index2 == -1) {
            System.out.println(target + " Not Found");
        } else {
            System.out.println("Target @ " + index2);
        }
    }
}
```

## Compile order

```plain
class HelloA {
    public HelloA(){
        System.out.println("HelloA");
    }
    {
        System.out.println("I'm A class");
    }
    static {
        System.out.println("static A");
    }
}

public class HelloB extends HelloA{
    public HelloB(){
        System.out.println("HelloB");
    }
    {
        System.out.println("I'm B class");
    }
    static {
        System.out.println("static B");
    }

    public static void main(String[] args) {
        new HelloB();
    }
}

Ans:
static A
static B
I'm A class
HelloA
I'm B class
HelloB
```

## Hierarchy

```plain
package org.example;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * @author Peter Yap
 * @datetime 2024/9/26 14:26
 */
public class Category {

    private String id;
    private String pid;
    private String name;

    public Category(String id, String pid, String name) {
        this.id = id;
        this.pid = pid;
        this.name = name;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getPid() {
        return pid;
    }

    public void setPid(String pid) {
        this.pid = pid;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public static void printRecursive(Map<String, List<Category>> map, String pid, Integer indent) {
        List<Category> list = map.get(pid);
        if(list == null) {
            return;
        }
        for(Category category : list) {
            System.out.println(indentString(indent) + category.getId() + " " + category.getName());
            printRecursive(map, category.getId(), indent + 1);
        }
    }

    public static void printHierarchy(List<Category> categoryList) {
        Map<String, List<Category>> map = new HashMap<>();
        for(Category category : categoryList) {
            List<Category> childList = map.get(category.getPid());
            if(childList == null) {
                childList = new ArrayList<>();
            }
            childList.add(category);
            map.put(category.getPid(), childList);
        }
        printRecursive(map, "0", 0);
    }

    public static String indentString(Integer indent) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < indent * 2; i++) {
            sb.append(" ");
        }
        return sb.toString();
    }

    public static void main(String[] args) {
        Category category1 = new Category("1", "0", "adam");
        Category category2 = new Category("2", "0", "john");
        Category category3 = new Category("3", "0", "tony");
        Category category4 = new Category("4", "1", "peter");
        Category category5 = new Category("5", "1", "jim");
        Category category6 = new Category("6", "2", "jean");
        Category category7 = new Category("7", "2", "jenny");
        Category category8 = new Category("8", "1", "sam");
        Category category9 = new Category("9", "3", "vint");
        Category category10 = new Category("10", "8", "alton");
        List<Category> categoryList = new ArrayList<>();
        categoryList.add(category1);
        categoryList.add(category2);
        categoryList.add(category3);
        categoryList.add(category4);
        categoryList.add(category5);
        categoryList.add(category6);
        categoryList.add(category7);
        categoryList.add(category8);
        categoryList.add(category9);
        categoryList.add(category10);

        printHierarchy(categoryList);

    }
}
```

## Symmetric Tree

```plain
package com.testing01;

class TreeNode {
    public int val;
    public TreeNode left, right;

    public TreeNode(int val) {
        this.val = val;
        this.left = this.right = null;
    }
}

public class SymmetryTree {

    public boolean isSymmetric(TreeNode root) {
        if (root == null)
            return true;

        return dfs(root.left, root.right);
    }

    public boolean dfs(TreeNode left, TreeNode right) {
        if (left == null && right == null)
            return true;

        if ((left != null && right == null) || (left == null && right != null)) {
            return false;
        }

        if (left.val != right.val) {
            return false;
        } else {
            return dfs(left.left, right.right) && dfs(left.right, right.left);
        }
    }
}
```

# C++

- C++ 支持指针，而 Java 没有指针的概念；
- C++ 支持多继承，而 Java 不支持多重继承，但允许一个类实现多个接口；
- 指针是一个变量，存储内存地址，可以指向其他变量或对象，可以使用*来访问内存地址的值，指针运行空值null，指针可以重新复制，指针可以释放内存销毁对象
- 引用是一个别名，为一个已经存在的变量或对象提高附加名称，引用必须在声明时初始化并且不能为null，引用初始化后更改对象(int &k = a)
- 虚函数，实现动态绑定，重写

# 前端

- **VUE**特性 双向数据绑定是通过 数据劫持 + 发布者-订阅者模式，ES5 Object.defineProperty来劫持，响应式界面
- v-model:value + @input
- v-if 是动态添加，v-show一开始渲染就存在只不过根据条件隐藏了还是存在dom中
- vue的key的作用是用于识别Vue 组件的实例在列表渲染中的身份。
- Proxy代理整个对象，Object.defineProperty只代理对象上的某个属性。



# 面试问题记录

producer - broker returncallback

consumer - broker ackcallback

rabbitmq交换机

db保证数据一致性 （分布式代码层面）

@Bean @Component

synchronized reentrantlock

脱敏信息加密 解密

transactional 范围

深度翻页

beanfactory factorybean

aop 动态代理

interceptor

@Controller @Repository @Service @Component 区别

explain字段
